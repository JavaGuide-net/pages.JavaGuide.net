import{_ as t,o as a,h as e,Q as r}from"./chunks/framework.da611722.js";const p="/assets/HTTP-四层协议传输.9f1eab8e.png",i="/assets/session无状态的解决办法.6406cfaf.png",s="/assets/HTTP-HTTPS-SSL-TLS.9eb672c7.png",o="/assets/https的安全通信演进过程.3d01063f.png",n="/assets/https-加密通信-对称加密不可行.adb706dc.png",l="/assets/https-加密通信-不同客户端分配不同的密钥.5aee0685.png",h="/assets/https-加密-公私钥加密.9ede7c91.png",d="/assets/公钥的获取方式-中间人.ab7d203c.png",c="/assets/客户端无法确认服务端的身份.21b7c84c.png",m="/assets/客户端如何去加密第三方结构用私钥去加密的证书.dca9dcab.png",u="/assets/第三方机构进行加密的过程.bec0a439.png",b="/assets/服务端返回的证书进行比对.ead96576.png",T="/assets/CA机构-客户端-服务端-签发-验证.db6e1164.png",J=JSON.parse('{"title":"分布式系统的基石HTTP协议与HTTPS协议 | JavaGuide","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://JavaGuide.net/百万架构师/分布式架构的基础/分布式系统的基石HTTP协议与HTTPS协议.html"}],["meta",{"name":"keywords","content":"分布式系统的基石HTTP协议与HTTPS协议 , JavaGuide , JavaGuide官网, Java面试指南, Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"分布式系统的基石HTTP协议与HTTPS协议 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"og:description","content":"分布式系统的基石HTTP协议与HTTPS协议 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://JavaGuide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"分布式系统的基石HTTP协议与HTTPS协议 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"twitter:description","content":"分布式系统的基石HTTP协议与HTTPS协议 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"sogou_site_verification","content":"fcAkazTXFd"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/分布式架构的基础/分布式系统的基石HTTP协议与HTTPS协议.md","filePath":"百万架构师/分布式架构的基础/分布式系统的基石HTTP协议与HTTPS协议.md","lastUpdated":1741277271000}'),_={name:"百万架构师/分布式架构的基础/分布式系统的基石HTTP协议与HTTPS协议.md"},P=r('<ul><li>了解客户端和服务端的请求原理</li><li>HTTP协议及其组成</li><li>HTTPS交互原理分析</li></ul><p>访问支付宝，微信的开放接口 都是基于HTTP</p><p>对外提供的开放服务 API都是基于HTTP协议的，</p><p>微服务中的服务之间的调用大部分都是基于HTTP协议的。</p><p>Web层提供http协议的对外接口</p><p><img src="'+p+'" alt="HTTP-四层协议传输"></p><p>http协议是基于TCP可靠通讯协议之上的</p><p>fiddler：这是一个抓包工具，抓取网络上一个请求。所有的请求都经过了fiddle。</p><p>下载地址：<a href="https://www.telerik.com/download/fiddler/fiddler4" target="_blank" rel="noreferrer">https://www.telerik.com/download/fiddler/fiddler4</a></p><p>post <a href="http://csdn.net" target="_blank" rel="noreferrer">http://csdn.net</a> htt/1.1</p><p>方法 URL/URI 协议的版本</p><h2 id="request-请求头" tabindex="-1">Request 请求头 <a class="header-anchor" href="#request-请求头" aria-label="Permalink to &quot;Request 请求头&quot;">​</a></h2><h2 id="response" tabindex="-1">Response <a class="header-anchor" href="#response" aria-label="Permalink to &quot;Response&quot;">​</a></h2><p>头部</p><ul><li>Host：目标地址</li><li>Connextion：链接地址</li><li>Referrer：做防盗链</li><li>Cookie：携带参数</li></ul><p>​</p><p>内容</p><p>[“headers”…]</p><p>Response</p><ul><li>http/1.1 200 OK</li><li>协议/版本号</li><li>响应状态码</li><li>状态码对应的原因</li></ul><p>头部信息</p><ul><li>Server:openresty 基于nigix和lua实现的高性能的web平台</li><li>Date</li><li>Connertion</li><li>......</li></ul><h2 id="url-uri" tabindex="-1">URL/URI <a class="header-anchor" href="#url-uri" aria-label="Permalink to &quot;URL/URI&quot;">​</a></h2><p>URL</p><p>网络上的资源位置</p><p><a href="http://www.gutapedu.com:80/java/index.html?name=mic#head" target="_blank" rel="noreferrer">http://www.gutapedu.com:80/java/index.html?name=mic#head</a></p><p>指定协议类型（ftp/https）</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Host</td><td>域名，然后解析成IP地址</td></tr><tr><td>Port</td><td>端口号（一般不写）</td></tr><tr><td>Path</td><td>资源路径（虚拟主机对应的路径名称）</td></tr><tr><td>Query-string</td><td>查询字符串</td></tr><tr><td>#head 片段标识符</td><td>页面某个地方有个一锚点，到最上边，到最下边</td></tr></tbody></table><p>URI</p><p>统一资源的标识符</p><ul><li>URI定位到互联网上的某一个资源</li><li>URL标识这个互联网上的一个地点</li></ul><p>​</p><h2 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Post</td><td>资源给你</td></tr><tr><td>Get</td><td>查询</td></tr><tr><td>Delete</td><td>删除</td></tr><tr><td>Put</td><td>做更新</td></tr><tr><td>Option</td><td>服务端告诉我这个URI支持的是什么类型 post get</td></tr><tr><td>Head</td><td>查询请求，拿到head信息，不要返回主体</td></tr></tbody></table><h1 id="http协议的特点" tabindex="-1">HTTP协议的特点 <a class="header-anchor" href="#http协议的特点" aria-label="Permalink to &quot;HTTP协议的特点&quot;">​</a></h1><h2 id="http协议是无状态的。" tabindex="-1">http协议是无状态的。 <a class="header-anchor" href="#http协议是无状态的。" aria-label="Permalink to &quot;http协议是无状态的。&quot;">​</a></h2><p>两次http请求之间是没有关系的。</p><p>http在服务端不需要记录请求的状态，省了很多开销，</p><p>比较灵活，应用面更广。</p><p>登录，在登录，在登录，哈哈哈</p><h2 id="无状态解决方法" tabindex="-1">无状态解决方法 <a class="header-anchor" href="#无状态解决方法" aria-label="Permalink to &quot;无状态解决方法&quot;">​</a></h2><p><img src="'+i+'" alt="session无状态的解决办法"></p><p>http协议引入了cookie机制，解决了http无状态的问题</p><p>cookie由服务端生成，保存在客户端，下一次请求携带cookie信息发送过来。</p><p>Tomicat中有session session有sessioinID （set-cookie ）</p><p>客户端保存 cookie.JSESSIONID</p><p>下次发送时携带cookie发送到服务端。</p><h2 id="不用session的原因" tabindex="-1">不用session的原因 <a class="header-anchor" href="#不用session的原因" aria-label="Permalink to &quot;不用session的原因&quot;">​</a></h2><p>需要通过session统一保存，</p><p>分布式架构中需要同步session，统一session的问题。所以我们很多时候自己扮演tomcat生成这样的一个角色，客户端的session信息，我是可以自己保存的，我可以开一个授权服务，专门生成Token，然后把Token返回给客户端的浏览器去保存。</p><h1 id="通信是明文的" tabindex="-1">通信是明文的 <a class="header-anchor" href="#通信是明文的" aria-label="Permalink to &quot;通信是明文的&quot;">​</a></h1><p>可以通过抓包工具，拿到http协议的数据</p><p>通信被第三方不法分子去抓取，可以拿到你的信息，可以监听，篡改。解决不安全问题。</p><h2 id="由https协议" tabindex="-1">由https协议 <a class="header-anchor" href="#由https协议" aria-label="Permalink to &quot;由https协议&quot;">​</a></h2><p>一种加密的超文本传输，发送过程中完全加密</p><p>基于TCP协议层之上去扩展的一个协议层。</p><p>https和http协议分层一模一样。</p><p><img src="'+s+'" alt="HTTP-HTTPS-SSL-TLS"></p><p>https的通信原理</p><p>怎么去实现安全传输的。</p><p>SSL(Secure Sockets Layer <a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="noreferrer">安全套接层</a>),</p><p>http 不加密</p><h1 id="https的通信原理" tabindex="-1">https的通信原理 <a class="header-anchor" href="#https的通信原理" aria-label="Permalink to &quot;https的通信原理&quot;">​</a></h1><h2 id="怎么去实现安全传输的" tabindex="-1">怎么去实现安全传输的？？ <a class="header-anchor" href="#怎么去实现安全传输的" aria-label="Permalink to &quot;怎么去实现安全传输的？？&quot;">​</a></h2><p><img src="'+o+'" alt="https的安全通信演进过程"></p><h2 id="需要加密" tabindex="-1">需要加密： <a class="header-anchor" href="#需要加密" aria-label="Permalink to &quot;需要加密：&quot;">​</a></h2><p><img src="'+n+'" alt="https-加密通信-对称加密不可行"></p><h2 id="所以要分配不同的密钥" tabindex="-1">所以要分配不同的密钥 <a class="header-anchor" href="#所以要分配不同的密钥" aria-label="Permalink to &quot;所以要分配不同的密钥&quot;">​</a></h2><p><img src="'+l+'" alt="https-加密通信-不同客户端分配不同的密钥"></p><h2 id="服务端怎么告诉客户端使用的哪一种加密算法" tabindex="-1">服务端怎么告诉客户端使用的哪一种加密算法 <a class="header-anchor" href="#服务端怎么告诉客户端使用的哪一种加密算法" aria-label="Permalink to &quot;服务端怎么告诉客户端使用的哪一种加密算法&quot;">​</a></h2><p>客户端无法全部都预置密钥，所以就需要在通信过程中把密钥发给客户端。如果在通信过程中拿到密钥的话，又是不安全传输。</p><p>涉及网络传输的就是一个不安全的。所以怎么去协商密钥的过程。</p><p>密钥的分发也很复杂，是每一次请求都分发，还是第一次分发，</p><h2 id="非对称性加密" tabindex="-1">非对称性加密 <a class="header-anchor" href="#非对称性加密" aria-label="Permalink to &quot;非对称性加密&quot;">​</a></h2><p><img src="'+h+'" alt="https-加密-公私钥加密"></p><h2 id="公钥怎么去拿" tabindex="-1">公钥怎么去拿？ <a class="header-anchor" href="#公钥怎么去拿" aria-label="Permalink to &quot;公钥怎么去拿？&quot;">​</a></h2><p><img src="'+d+'" alt="公钥的获取方式-中间人"></p><h2 id="密钥的泄露问题怎么解决" tabindex="-1">密钥的泄露问题怎么解决 <a class="header-anchor" href="#密钥的泄露问题怎么解决" aria-label="Permalink to &quot;密钥的泄露问题怎么解决&quot;">​</a></h2><p>问题在于中间人身份的不确定性</p><p>需要一个中间人去证明这个请求是服务端的。</p><p>服务端把需要传递给客户端的公钥再做一次加密。</p><p>第三方也使用非对称加密</p><p><img src="'+c+'" alt="客户端无法确认服务端的身份"></p><p><img src="'+m+'" alt="客户端如何去加密第三方结构用私钥去加密的证书"></p><h2 id="第三方机构" tabindex="-1">第三方机构 <a class="header-anchor" href="#第三方机构" aria-label="Permalink to &quot;第三方机构&quot;">​</a></h2><p>不法分子有可能先获得一个公钥，然后拦截请求之后，替换掉证书。</p><p><img src="'+u+'" alt="第三方机构进行加密的过程"></p><p><img src="'+b+'" alt="服务端返回的证书进行比对"></p><h2 id="客户端的数字证书内部内置解密算法。" tabindex="-1">客户端的数字证书内部内置解密算法。 <a class="header-anchor" href="#客户端的数字证书内部内置解密算法。" aria-label="Permalink to &quot;客户端的数字证书内部内置解密算法。&quot;">​</a></h2><p>对称加密 密钥a 密钥a</p><p>密钥是统一的。</p><p>拿到密钥后，一个更改其他的请求了</p><p>每个客户端分配不同的密钥。</p><p>服务端怎么告诉客户端要使用哪种加密算法</p><p>客户端不能预置密钥，</p><p>密钥是网络传输的。</p><p>密钥的分发处理起来很麻烦。什么时候分发，怎么分发</p><p>每个客户端都可以拿到一个公钥，不同的公钥，每一个客户端拿到不同的公钥。</p><p>服务端存储私钥</p><p>公钥怎么去传输？？？</p><p>服务端利用网络去分发是一定可以截取的，</p><p>中间人可以截取。</p><p>引入第三方。</p><p>第三方，通过自己的私钥去加密公钥</p><p>第三方机构 （CA）</p><p>第三方机构（CA）对使用私钥服务端的公钥进行加密</p><p>数字证书</p><p>证书编号（MD5）。</p><p>域名</p><p>所有者</p><p>有效期</p><p>加密（server短的公钥）</p><p>数字签名的生成算法：MD5</p><p>客户端对证书进行加密</p><p>服务端下载数字证书以后，利用内置的公钥进行解密，根据证书的签名算法，对证书的内容进行加密，然后跟服务端发给客户端的消息进行比较。</p><p>浏览器或操作系统都会内置一些证书</p><p>阿里或微信在你支付的时候会进行提示你进行下载证书。</p><p><img src="'+T+'" alt="CA机构-客户端-服务端-签发-验证"></p><h3 id="_1-客户端发起请求-client-hello-包" tabindex="-1">1.客户端发起请求(Client Hello 包) <a class="header-anchor" href="#_1-客户端发起请求-client-hello-包" aria-label="Permalink to &quot;1.客户端发起请求(Client Hello 包)&quot;">​</a></h3><p>三次握手，建立 TCP 连接</p><p>支持的协议版本(TLS/SSL)</p><p>客户端生成的随机数 client.random，后续用于生成“对话密钥”</p><p>客户端支持的加密算法</p><p>sessionid，用于保持同一个会话（如果客户端与服务器费尽周折建立了一个 HTTPS 链接，刚建完就断了，也太可惜）</p><h3 id="_2-服务端收到请求-然后响应-server-hello" tabindex="-1">2.服务端收到请求，然后响应（Server Hello） <a class="header-anchor" href="#_2-服务端收到请求-然后响应-server-hello" aria-label="Permalink to &quot;2.服务端收到请求，然后响应（Server Hello）&quot;">​</a></h3><p>确认加密通道协议版本</p><p>服务端生成的随机数 server.random，后续用于生成“对话密钥”</p><p>确认使用的加密算法（用于后续的握手消息进行签名防止篡改）</p><p>服务器证书（CA 机构颁发给服务端的证书）</p><h3 id="_3-客户端收到证书进行验证" tabindex="-1">3.客户端收到证书进行验证 <a class="header-anchor" href="#_3-客户端收到证书进行验证" aria-label="Permalink to &quot;3.客户端收到证书进行验证&quot;">​</a></h3><p>验证证书是否是上级 CA 签发的，在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级地进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信</p><p>服务端返回的证书中会包含证书的有效期，可以通过失效日期来验证 证书是否过期</p><p>验证证书是否被吊销了</p><p>前面我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名 证书里的签名算法字段 sha256RSA 表示 CA 机构使用 sha256 对证书进行摘要，然后使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后，只有公钥才能进行验签。</p><p>浏览器使用内置在操作系统上的CA机构的公钥对服务器的证书进行验签。确定这个证书是不是由正规的机构颁发。验签之后得知 CA 机构使用 sha256 进行证书摘要，然后客户端再使用 sha256 对证书内容进行一次摘要，如果得到的值和服务端返回的证书验签之后的摘要相同，表示证书没有被修改过。</p><p>验证通过后，就会显示绿色的安全字样</p><p>客户端生成随机数，验证通过之后，客户端会生成一个随机数 pre-master secret，客户端根据之前的：Client.random + sever.random + pre-master 生成对称密钥然后使用证书中的公钥进行加密，同时利用前面协商好的加密算法，将握手消息取 HASH 值，然后用“随机数加密握手消息+握手消息 HASH 值（签名）”然后传递给服务器端；(在这里之所以要取握手消息的HASH 值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。)</p><h3 id="_4-服务端接收随机数" tabindex="-1">4.服务端接收随机数 <a class="header-anchor" href="#_4-服务端接收随机数" aria-label="Permalink to &quot;4.服务端接收随机数&quot;">​</a></h3><p>服务端收到客户端的加密数据以后，用自己的私钥对密文进行解密。然后得到client.random/server.random/pre-master secret，再用随机数密码 解密 握手消息与 HASH 值，并与传过来的。</p><p>HASH 值做对比确认是否一致。</p><p>然后用随机密码加密一段握手消息(握手消息+握手消息的 HASH 值)给客户端</p><h3 id="_5-客户端接收消息" tabindex="-1">5.客户端接收消息 <a class="header-anchor" href="#_5-客户端接收消息" aria-label="Permalink to &quot;5.客户端接收消息&quot;">​</a></h3><p>客户端用随机数解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前交互过程中生成的 pre master</p><p>secret / client.random/server.random 通过算法得出 session</p><p>Key，作为后续交互过程中的对称密钥</p><h1 id="web攻击手段" tabindex="-1">WEB攻击手段 <a class="header-anchor" href="#web攻击手段" aria-label="Permalink to &quot;WEB攻击手段&quot;">​</a></h1><h2 id="主动攻击" tabindex="-1">主动攻击 <a class="header-anchor" href="#主动攻击" aria-label="Permalink to &quot;主动攻击&quot;">​</a></h2><h3 id="我是一个主动的行为-去做sql注入。" tabindex="-1">我是一个主动的行为，去做SQL注入。 <a class="header-anchor" href="#我是一个主动的行为-去做sql注入。" aria-label="Permalink to &quot;我是一个主动的行为，去做SQL注入。&quot;">​</a></h3><h2 id="被动攻击" tabindex="-1">被动攻击 <a class="header-anchor" href="#被动攻击" aria-label="Permalink to &quot;被动攻击&quot;">​</a></h2><h3 id="跨站脚本攻击、请求伪造" tabindex="-1">跨站脚本攻击、请求伪造 <a class="header-anchor" href="#跨站脚本攻击、请求伪造" aria-label="Permalink to &quot;跨站脚本攻击、请求伪造&quot;">​</a></h3><p>csrf(Cross-Site Request Forgeries )跨站请求伪造攻击</p><p>看了一篇文章的介绍，<a href="https://link.jianshu.com?t=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F22521378%3Futm_medium%3Dsocial%26utm_source%3Dqq" target="_blank" rel="noreferrer">csrf</a> ，引用下其中评论的一段总结：</p><p>CSRF(Cross Site Request Forgery)即跨站请求伪造。就是利用后台有规律的接口，例如 localhost<a href="https://link.jianshu.com?t=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fwww.baidu.com%2FdeleteAriticle.php%253Fid%253D3%2526username%253Dxiaoxiao" target="_blank" rel="noreferrer">/deleteAriticle.php?id=3&amp;username=xiaoxiao</a>，攻击者在被攻击的网站页面嵌入这样的代码，当用户xiaoxiao访问该网站的时候，会发起这个请求。服务器会删除id为3的数据。 客户端防范：对于数据库的修改请求，全部使用POST提交，禁止使用GET请求。 服务器端防范：一般的做法是在表单里面添加一段隐藏的唯一的token(请求令牌)。</p>',153),q=[P];function f(k,H,S,g,v,x){return a(),e("div",null,q)}const w=t(_,[["render",f]]);export{J as __pageData,w as default};

import{_ as a,o as e,h as t,Q as s}from"./chunks/framework.da611722.js";const n="/assets/事务就是Socket连接.bcbaff95.png",o="/assets/JDBC的链接.11bb3ef4.png",p="/assets/SQL的update过程图解.14c91f29.png",l="/assets/事务AOP图解.2fc54d0e.png",q=JSON.parse('{"title":"数据库事务操作原理及SpringAOP配置 | JavaGuide","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://JavaGuide.net/百万架构师/Spring 源码分析/数据库事务操作原理及SpringAOP配置.html"}],["meta",{"name":"keywords","content":"数据库事务操作原理及SpringAOP配置 , JavaGuide , JavaGuide官网, Java面试指南, Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"数据库事务操作原理及SpringAOP配置 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"og:description","content":"数据库事务操作原理及SpringAOP配置 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://JavaGuide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"数据库事务操作原理及SpringAOP配置 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"twitter:description","content":"数据库事务操作原理及SpringAOP配置 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"sogou_site_verification","content":"fcAkazTXFd"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/Spring 源码分析/数据库事务操作原理及SpringAOP配置.md","filePath":"百万架构师/Spring 源码分析/数据库事务操作原理及SpringAOP配置.md","lastUpdated":1741277271000}'),r={name:"百万架构师/Spring 源码分析/数据库事务操作原理及SpringAOP配置.md"},i=s('<h2 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h2><h5 id="事务就是-socket-连接" tabindex="-1">事务就是 Socket 连接 <a class="header-anchor" href="#事务就是-socket-连接" aria-label="Permalink to &quot;事务就是 Socket 连接&quot;">​</a></h5><p><img src="'+n+'" alt="事务就是Socket连接"></p><h5 id="jdbc-的连接" tabindex="-1">JDBC 的连接 <a class="header-anchor" href="#jdbc-的连接" aria-label="Permalink to &quot;JDBC 的连接&quot;">​</a></h5><p><img src="'+o+'" alt="JDBC的链接"></p><h6 id="_1-如果是-select-拿到直接返回就好了" tabindex="-1">1. 如果是 SELECT 拿到直接返回就好了 <a class="header-anchor" href="#_1-如果是-select-拿到直接返回就好了" aria-label="Permalink to &quot;1. 如果是 SELECT 拿到直接返回就好了&quot;">​</a></h6><h6 id="_2-把找出来的记录放到内存中" tabindex="-1">2. 把找出来的记录放到内存中 <a class="header-anchor" href="#_2-把找出来的记录放到内存中" aria-label="Permalink to &quot;2. 把找出来的记录放到内存中&quot;">​</a></h6><h6 id="_3-异常检查-有没有这条数据。再检查-sql-语句是不是有语法错误-等等-然后在内存中修改这条数据。修改完以后-会去检查-比如说外键关联了之类的问题。发现不能改了又会报错。" tabindex="-1">3. 异常检查：有没有这条数据。再检查 <code>SQL</code> 语句是不是有语法错误，等等，然后在内存中修改这条数据。修改完以后，会去检查，比如说外键关联了之类的问题。发现不能改了又会报错。 <a class="header-anchor" href="#_3-异常检查-有没有这条数据。再检查-sql-语句是不是有语法错误-等等-然后在内存中修改这条数据。修改完以后-会去检查-比如说外键关联了之类的问题。发现不能改了又会报错。" aria-label="Permalink to &quot;3. 异常检查：有没有这条数据。再检查 `SQL` 语句是不是有语法错误，等等，然后在内存中修改这条数据。修改完以后，会去检查，比如说外键关联了之类的问题。发现不能改了又会报错。&quot;">​</a></h6><blockquote><p>只有当更新以后完全没有问题了，才会把这条数据给替换掉。</p></blockquote><blockquote><p>有些数据库采用的是增量，有些数据库采用的是直接替换。</p><p>一般数据库都是采用增量的模式，会用内存中的数据把原来的数据给覆盖掉。</p></blockquote><h6 id="_4-数据操作没有任何异常的话-更新原始表-写日志" tabindex="-1">4. 数据操作没有任何异常的话，更新原始表，写日志 <a class="header-anchor" href="#_4-数据操作没有任何异常的话-更新原始表-写日志" aria-label="Permalink to &quot;4. 数据操作没有任何异常的话，更新原始表，写日志&quot;">​</a></h6><blockquote><p>数据库一定会写日志</p></blockquote><h6 id="_5-返回状态码" tabindex="-1">5. 返回状态码 <a class="header-anchor" href="#_5-返回状态码" aria-label="Permalink to &quot;5. 返回状态码&quot;">​</a></h6><h5 id="update-过程图解" tabindex="-1">update 过程图解： <a class="header-anchor" href="#update-过程图解" aria-label="Permalink to &quot;update 过程图解：&quot;">​</a></h5><p><img src="'+p+`" alt="SQL的update过程图解"></p><h4 id="锁表-行锁、表锁" tabindex="-1">锁表-行锁、表锁 <a class="header-anchor" href="#锁表-行锁、表锁" aria-label="Permalink to &quot;锁表-行锁、表锁&quot;">​</a></h4><p>​ 这条更新的目标记录，如果需要对这个表进行扫描的话，这里会把整个表都锁住，然后把整张表都同步到内存中，那么这个表就不允许任何的增删改操作。如果，这条记录查出来，放在内存里边的话，这时候就是行锁。这条记录如果转移到缓存区里的话，这条记录绝对绝不允许别人去修改的。只有当我把缓冲区的数据消掉以后，更新到数据库里边，这条记录才会被解锁，其他更新才能进行。</p><h5 id="日志" tabindex="-1">日志： <a class="header-anchor" href="#日志" aria-label="Permalink to &quot;日志：&quot;">​</a></h5><p>Mysql : binlog</p><p>记录事务的开始到结束，还有中间的报错，以及整个链接成功与否还有返回结果，状态码，查出来是什么，更新的是什么。都会记录下来。如果报错了，就不会再记录了，它会再找回去，逆向地一步一步执行回去。这就是要给回滚的过程，就会根据这个记录一条一条回滚。日志中，一定要包括，操作的记录、日志、事件。</p><p>这个 log 非常重要。回滚也会记录日志。</p><blockquote><p>如果，id 自增的话，添加 id = 5 ；失败，回滚，然后，id 下一次就会是 6。</p></blockquote><h5 id="insert" tabindex="-1">insert <a class="header-anchor" href="#insert" aria-label="Permalink to &quot;insert&quot;">​</a></h5><p>​ 首先检查原始表中有没有相关联的记录，先把相关联的记录写到内存中来，只有我们的缓冲区没有任何的异常，它才会把这条记录写进去。（通常会根据 id 来识别，数据类型，外键，索引）</p><h5 id="delete" tabindex="-1">Delete <a class="header-anchor" href="#delete" aria-label="Permalink to &quot;Delete&quot;">​</a></h5><p>​ 我们先把相关联的数据放到内存中，比较之后，没有异常，同步到数据库表中去。</p><p>增删改都有锁 ， for update</p><div class="language-mysql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> 会把整个表都锁住了</span></span>
<span class="line"><span style="color:#79B8FF;">DELECT</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">FROM</span><span style="color:#E1E4E8;"> member;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">--</span><span style="color:#24292E;"> 会把整个表都锁住了</span></span>
<span class="line"><span style="color:#005CC5;">DELECT</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">FROM</span><span style="color:#24292E;"> member;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h6 id="sql-struction-query-language-本身就是一种协议。" tabindex="-1">SQL （Struction Query Language）本身就是一种协议。 <a class="header-anchor" href="#sql-struction-query-language-本身就是一种协议。" aria-label="Permalink to &quot;SQL （Struction Query Language）本身就是一种协议。&quot;">​</a></h6><p>​ 事务只是一个概念，多条语句一起执行，只有一个连接，如果一条一条执行，那就有多个连接。</p><p>一个连接一个 <strong>Socket</strong> 。</p><p>如果你 <code>setAutoCommit(false);</code></p><p><code>commit();</code> 手动提交就行了。</p><h2 id="aop" tabindex="-1">AOP： <a class="header-anchor" href="#aop" aria-label="Permalink to &quot;AOP：&quot;">​</a></h2><p>AOP ： 解耦。（专人干专事） Aspect（切面）</p><p>面向接口编程是一种接口，</p><p>MVC 编程是一种解耦。</p><p>三层架构 Dao、Service、Action 是一种解耦</p><p>微服务化也是一种解耦</p><p>以 Class 为单位的纵向的解耦（传统）</p><p>横切，横向解耦（面向范畴可能多个类之间）</p><h4 id="如何切面" tabindex="-1">如何切面： <a class="header-anchor" href="#如何切面" aria-label="Permalink to &quot;如何切面：&quot;">​</a></h4><p>规则</p><p>面向切面编程就是 <strong>面向规则编程</strong> 。</p><table><thead><tr><th>Spring</th><th>JDK</th><th></th></tr></thead><tbody><tr><td>织入</td><td>字节码重组</td><td><code>ProxyClassLoad</code></td></tr><tr><td>增强</td><td>动态代理</td><td><code>InvocationHandler</code></td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>切面</td><td>规则：事务管理的切面由Spring 提供，业务相关的切面由自己实现</td></tr><tr><td>切点</td><td>能够满足虚拟切面规则的所有入口</td></tr><tr><td>通知</td><td>满足条件的回调</td></tr></tbody></table><p>自古文人都是贼；这些底层都是一样的。叫 <strong>借鉴</strong></p><p><strong>Spring MVC、Spring WebFlux、Spring Boot</strong></p><h5 id="事务aop图解" tabindex="-1">事务AOP图解： <a class="header-anchor" href="#事务aop图解" aria-label="Permalink to &quot;事务AOP图解：&quot;">​</a></h5><p><img src="`+l+`" alt="事务AOP图解"></p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Before</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;aspect()&amp;&amp;args(id)&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">beforeArgId</span><span style="color:#E1E4E8;">(JoinPoint joinPoint, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> id){</span></span>
<span class="line"><span style="color:#E1E4E8;">    log.</span><span style="color:#B392F0;">info</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;beforeArgId &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> joinPoint </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;</span><span style="color:#79B8FF;">\\t</span><span style="color:#9ECBFF;">ID:&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> id);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Before</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;aspect()&amp;&amp;args(id)&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">beforeArgId</span><span style="color:#24292E;">(JoinPoint joinPoint, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> id){</span></span>
<span class="line"><span style="color:#24292E;">    log.</span><span style="color:#6F42C1;">info</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;beforeArgId &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> joinPoint </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;</span><span style="color:#005CC5;">\\t</span><span style="color:#032F62;">ID:&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> id);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>annotation</strong> 更加强大</p>`,52),c=[i];function d(h,u,m,b,y,g){return e(),t("div",null,c)}const _=a(r,[["render",d]]);export{q as __pageData,_ as default};

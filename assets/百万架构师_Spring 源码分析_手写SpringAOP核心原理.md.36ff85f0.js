import{_ as e,o as a,h as n,Q as t}from"./chunks/framework.da611722.js";const v=JSON.parse('{"title":"手写SpringAOP核心原理 | Java面试指南","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://javaguide.net/百万架构师/Spring 源码分析/手写SpringAOP核心原理.html"}],["meta",{"name":"keywords","content":"手写SpringAOP核心原理 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | UML中国 | UML ｜ PlantUML ｜不止极客,nogeek,educode,教育编程,编程教育|Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"手写SpringAOP核心原理 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"og:description","content":"手写SpringAOP核心原理 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:site","content":"https://javaguide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"手写SpringAOP核心原理 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"twitter:description","content":"手写SpringAOP核心原理 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 始于极客，不止极客｜educode｜educode.cn|nogeek|nogeek.cn｜CTO|架构师｜后端组长｜创业者｜高并发｜高性能｜高可用|技术合伙人｜架构咨询"}],["meta",{"name":"twitter:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/Spring 源码分析/手写SpringAOP核心原理.md","filePath":"百万架构师/Spring 源码分析/手写SpringAOP核心原理.md","lastUpdated":1740370683000}'),o={name:"百万架构师/Spring 源码分析/手写SpringAOP核心原理.md"},p=t('<h5 id="已完成" tabindex="-1">已完成 <a class="header-anchor" href="#已完成" aria-label="Permalink to &quot;已完成&quot;">​</a></h5><ul><li>Spring IOC</li><li>Spring DI</li><li>Spring MVC</li></ul><h5 id="继续完善" tabindex="-1">继续完善： <a class="header-anchor" href="#继续完善" aria-label="Permalink to &quot;继续完善：&quot;">​</a></h5><p>Spring AOP 的功能，基于 Spring IOC 和 DI 去完成</p><p>未完成： Spring AOP、Spring Transaction、Spring JDBC、自己手写 ORM 框架。</p><p>​ Spring IOC 入口，DispatcherServlet，通过 DispatcherServlet 启动一个 ApplicationContext 容器，由 ApplicationContext 启动一个 IOC 的操作，通过 DarianBeanDefinitionReader 读进来，变成一个 DarianBeanDefinition，有一个 DI 过程，有一个依赖注入，完成之后，会把所有的对象封装成 BeanWrapper，再把 BeanWrapper 保存在容器中。DI 是从一个 getBean 开始的。 IOC 是从 refresh() 开始的。</p><p>​ 所有的对象在 IOC 中都有一个代理的过程，在 Spring 中真实的对象，我们基本上是拿不到的。我们会有一个 AOP 的过程，我们代理的过程主要是由一个掌控力，代理之后，对象都是由 Spring 去掌控了，而不是最原始的对象了。我们 Spring 只是为了帮你保存下来最原始的对象，不会做任何更改，我们 Spring 操作的都是被代理过的对象。</p><p>​ BeanWrapper中，我们保存了最原始的对象和代理后的对象。</p><p>​ Spring 会根据你一个目标接口，也就是目标的一个类，有没有实现接口。Java 中不能支持多实现的。如果你实现了接口，他就会选择 JDK， 如果没有实现，他就会选择 Cglib。它是有策略的。</p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">aop:pointcut</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">expression</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;execution(* com.gupaoedu.vip.aop.service..*(..))&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;simplePointcut&quot;</span><span style="color:#E1E4E8;">/&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">aop:pointcut</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">expression</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;execution(* com.gupaoedu.vip.aop.service..*(..))&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;simplePointcut&quot;</span><span style="color:#24292E;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用的时候要调代理对象，但是判断的时候要调原生对象。</p>',11),s=[p];function i(r,l,c,d,g,u){return a(),n("div",null,s)}const S=e(o,[["render",i]]);export{v as __pageData,S as default};

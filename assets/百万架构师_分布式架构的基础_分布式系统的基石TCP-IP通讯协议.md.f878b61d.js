import{_ as a,o as e,h as t,Q as r}from"./chunks/framework.da611722.js";const p="/assets/从集中式的架构到分布式架构粗粒度的架构模型图.b6388b3c.png",i="/assets/一个请求四层协议的发送步骤.0fc138b5.png",o="/assets/一个请求四层协议的接收步骤.4ef497b6.png",n="/assets/请求DNS地址-拿到服务器上的内容.9d28f6d0.png",l="/assets/三次握手SYN攻击.4702104f.png",s="/assets/四次挥手协议步骤.00eacbd8.png",h="/assets/发送端-接收端-TCP缓冲区.c778f53a.png",c="/assets/TCP缓冲区发送缓冲区.2c758f2b.jpg",d="/assets/TCP缓冲区发送接收.3eb89096.jpg",P="/assets/TCP缓冲区发送接收ACK.e18bac8d.jpg",m="/assets/TCP缓冲区发送继续发送.cb6b2b0c.jpg",b="/assets/TCP缓冲区发送再次发送.c8e4dbfd.jpg",u="/assets/APP通过Socket和服务端通信.cc038bab.png",_="/assets/Client-Server-BIO图解.dd4c7771.png",k="/assets/Client-Server-BIO图解-Server-Thread.0dc3911e.png",I="/assets/TCP-发送端-接收端-TCP缓冲区.f41186b4.png",f="/assets/Client-Server-NIO图解.7b03eea9.png",B=JSON.parse('{"title":"分布式系统的基石TCP-IP通讯协议 | JavaGuide","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://JavaGuide.net/百万架构师/分布式架构的基础/分布式系统的基石TCP-IP通讯协议.html"}],["meta",{"name":"keywords","content":"分布式系统的基石TCP-IP通讯协议 , JavaGuide , JavaGuide官网, Java面试指南, Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"分布式系统的基石TCP-IP通讯协议 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"og:description","content":"分布式系统的基石TCP-IP通讯协议 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://JavaGuide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"分布式系统的基石TCP-IP通讯协议 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"twitter:description","content":"分布式系统的基石TCP-IP通讯协议 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://JavaGuide.net/JavaGuide-og.png"}],["meta",{"name":"sogou_site_verification","content":"fcAkazTXFd"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/分布式架构的基础/分布式系统的基石TCP-IP通讯协议.md","filePath":"百万架构师/分布式架构的基础/分布式系统的基石TCP-IP通讯协议.md","lastUpdated":1741277271000}'),C={name:"百万架构师/分布式架构的基础/分布式系统的基石TCP-IP通讯协议.md"},T=r('<ol><li>通讯协议在分布式架构中的核心应用</li><li>深入料及TCP/IP和UDP/IP通信协议</li><li>TCP流量整形</li><li>基于Java自身技术实现系统通讯</li><li>多任务处理及优化</li><li>了解什么是NIO</li><li>组播协议 Multicast</li></ol><h2 id="从集中式的架构到分布式架构粗粒度的架构模型图" tabindex="-1">从集中式的架构到分布式架构粗粒度的架构模型图 <a class="header-anchor" href="#从集中式的架构到分布式架构粗粒度的架构模型图" aria-label="Permalink to &quot;从集中式的架构到分布式架构粗粒度的架构模型图&quot;">​</a></h2><p><img src="'+p+`" alt="从集中式的架构到分布式架构粗粒度的架构模型图"></p><p>相当于是在整个架构层面上去做一个分层，分层以后会存在按照某一个领域去切分的服务层，存在web层。</p><p>​ 如果我们以前是在一个独立的服务模型里边，不需要涉及远程通信，唯一的远程通讯就是客户端和远程端的通讯，现在变成一个分布式架构，那么就意味着：服务层之间彼此会通讯，这样一个通讯的话，就会涉及到一个通讯协议，比如我们现在Web层调用Dubbo层是通过Dubbo协议去调用的，然后Dubbo调用基础服务，是通过socked的TCP通讯去完成一些服务间的对接。</p><p>​ 这是通讯在整个分布式架构中的用途。</p><p>​ 如果说没有一个远程通信的话，就意味着我们的分布式架构就没有存在的意义和价值。</p><p>所以说：</p><p>​ 在整个架构里边，通信会涉及协议、序列化、网络通信协议底层的TCP协议和UDP协议。</p><h1 id="任务目标" tabindex="-1">任务目标 <a class="header-anchor" href="#任务目标" aria-label="Permalink to &quot;任务目标&quot;">​</a></h1><h2 id="怎么完成一个远程通信" tabindex="-1">怎么完成一个远程通信？？？ <a class="header-anchor" href="#怎么完成一个远程通信" aria-label="Permalink to &quot;怎么完成一个远程通信？？？&quot;">​</a></h2><p>如果没有远程通信，就没有所谓的分布式系统，我们发送一个消息，会被某一个接收端去接收，那这个消息的形式有很多种。</p><h2 id="传输的数据类型" tabindex="-1">传输的数据类型 <a class="header-anchor" href="#传输的数据类型" aria-label="Permalink to &quot;传输的数据类型&quot;">​</a></h2><p>1． 字节流</p><p>2． 字节数组</p><p>3． java对象</p><h2 id="协议类型" tabindex="-1">协议类型 <a class="header-anchor" href="#协议类型" aria-label="Permalink to &quot;协议类型&quot;">​</a></h2><p>外部的系统收到这样一个请求以后需要做一个相应的处理，那这种基于消息方式的通信，在我们的网络层里边，一般来说就涵盖两种。</p><ol><li><pre><code>TCP/IP协议
</code></pre></li><li><pre><code>UDP/IP协议
</code></pre></li></ol><h1 id="网络领域的知识" tabindex="-1">网络领域的知识 <a class="header-anchor" href="#网络领域的知识" aria-label="Permalink to &quot;网络领域的知识&quot;">​</a></h1><h2 id="协议" tabindex="-1">协议： <a class="header-anchor" href="#协议" aria-label="Permalink to &quot;协议：&quot;">​</a></h2><p>TCP/UDP/multicast</p><h2 id="io" tabindex="-1">IO <a class="header-anchor" href="#io" aria-label="Permalink to &quot;IO&quot;">​</a></h2><p>远程通信一定涉及IO的形式（BIO、NIO、AIO）</p><h2 id="socket" tabindex="-1">Socket <a class="header-anchor" href="#socket" aria-label="Permalink to &quot;Socket&quot;">​</a></h2><p>套接字</p><h2 id="nio" tabindex="-1">NIO <a class="header-anchor" href="#nio" aria-label="Permalink to &quot;NIO&quot;">​</a></h2><p>（Netty/Mina）</p><h2 id="序列化和反序列化" tabindex="-1">序列化和反序列化 <a class="header-anchor" href="#序列化和反序列化" aria-label="Permalink to &quot;序列化和反序列化&quot;">​</a></h2><p>在网络通信中需要传输一个对象的话，就涉及序列化和反序列化了。</p><h1 id="一个http请求在整个网络中的请求过程" tabindex="-1">一个Http请求在整个网络中的请求过程 <a class="header-anchor" href="#一个http请求在整个网络中的请求过程" aria-label="Permalink to &quot;一个Http请求在整个网络中的请求过程&quot;">​</a></h1><h2 id="基于osi的七层网络模型" tabindex="-1">基于OSI的七层网络模型 <a class="header-anchor" href="#基于osi的七层网络模型" aria-label="Permalink to &quot;基于OSI的七层网络模型&quot;">​</a></h2><p>（ <a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_1" target="_blank" rel="noreferrer">应用层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_2" target="_blank" rel="noreferrer">表示层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_3" target="_blank" rel="noreferrer">会话层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_4" target="_blank" rel="noreferrer">传输层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_5" target="_blank" rel="noreferrer">网络层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_6" target="_blank" rel="noreferrer">数据链路层</a>、<a href="https://baike.baidu.com/item/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/1441391?fr=aladdin#3_7" target="_blank" rel="noreferrer">物理层</a>）</p><h2 id="tcp-ip的四层概念模型" tabindex="-1">TCP/IP的四层概念模型 <a class="header-anchor" href="#tcp-ip的四层概念模型" aria-label="Permalink to &quot;TCP/IP的四层概念模型&quot;">​</a></h2><p>​ （ <a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915#5_1" target="_blank" rel="noreferrer">网络接口层</a>、<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915#5_2" target="_blank" rel="noreferrer">网络层</a>、<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915#5_3" target="_blank" rel="noreferrer">传输层</a>、<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915#5_4" target="_blank" rel="noreferrer">应用层</a>）</p><p>网络为什么要分层，以及在通信时，我们的数据是怎么去传输的。</p><p>首先是我们打开一个浏览器，浏览一个网站，这时候相当于应用程序和客户端会产生一个交互。交互就是 TCP的三次握手协议。握手协议是建立一个连接。那在整个通信过程中，数据到底是怎么一个传输方式呢？</p><p><img src="`+i+'" alt="一个请求四层协议的发送步骤"></p><p>先增加一个TCP头，表示一个协议头，</p><p>第二个增加IP头，因为IP地址是网卡在网络中的一个通讯地址，相当于要给门牌号，有时候会提示IP地址冲突，因为IP地址是不能冲突的，相当于小区内部的门牌号，是我们网卡的唯一的通讯地址，相当于我们的门牌号。</p><p>增加MAC头，MAC头是我们的网卡地址，标识的是这个数据包要发送到的网卡地址，增加的IP头是目标的IP头，它本身自带当前的源IP头。</p><p>到了物理层，转换成一个Byte流进行一个传输，通过网络通讯进行一个传输。</p><p>比作寄包裹的话：</p><ul><li>选择快递公司 <ul><li>地方，省市 <ul><li>姓名，门牌号</li></ul></li></ul></li></ul><p>IP定位到地方，MAC头定位到它是发给你的，</p><p>IP协议，提供了一组数据报文服务，每组服务都是由网络统一处理分发的</p><p>IP头有两个东西，一个目的IP地址，一个源IP地址。</p><p>接收方的接收步骤</p><p><img src="'+o+'" alt="一个请求四层协议的接收步骤"></p><p>​ 当我们的目标主机收到这样一个目标以后，收到网络上的一个数据帧以后，它就会开始从协议层由底向上升。先到网卡，有两种形式，一种是所有数据包都接收，一种是，先判断这个MAC头是不是我的，如果不是我的就不会进来。所以拿到这个数据以后，到数据链路层去摘取这个MAC头，去判断当前的一个网卡地址，和发送的MAC是不是匹配。</p><p>​ 网络层，会摘取IP头，如果不是自己的就会做一个转发，最后到了传输层。协议层会携带端口号，通过端口号，定位到具体的进程内，把这个数据包发送到我们对应的接收端。</p><p>MAC头是唯一的，理论上是可以通过MAC头去发送消息，MAC就像身份证一样，他是一个唯一的，但是我要去定位，是用IP去定位到我要发送到那个服务器，是个分层结构！</p><p>​ 网络是一个分层，它会有四层。</p><h1 id="ip协议" tabindex="-1">IP协议 <a class="header-anchor" href="#ip协议" aria-label="Permalink to &quot;IP协议&quot;">​</a></h1><p>TCP/UDP协议都是基于IP网络协议之上的，IP协议会提供一组数据报文服务，每组报文会由网络去统一处理和分发的。</p><p>每组报文都必须包含目的地址的地址段、IP层地址段。</p><p>IP协议，不可靠，尽力而为的协议，报文丢失，无序，或者说重复发送的情况。</p><h2 id="tcp可靠协议" tabindex="-1">TCP可靠协议 <a class="header-anchor" href="#tcp可靠协议" aria-label="Permalink to &quot;TCP可靠协议&quot;">​</a></h2><h2 id="udp不可靠协议" tabindex="-1">UDP不可靠协议 <a class="header-anchor" href="#udp不可靠协议" aria-label="Permalink to &quot;UDP不可靠协议&quot;">​</a></h2><p>TCP头里边有目标端口号</p><h1 id="协议-1" tabindex="-1">协议 <a class="header-anchor" href="#协议-1" aria-label="Permalink to &quot;协议&quot;">​</a></h1><p>协议是两种网络通讯中达成的一个约定。</p><p>协议目的：</p><p>就是规范好通讯之间的约定。</p><h2 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h2><h2 id="超文本传输协议" tabindex="-1">超文本传输协议 <a class="header-anchor" href="#超文本传输协议" aria-label="Permalink to &quot;超文本传输协议&quot;">​</a></h2><p>拿到服务器上不同格式的数据</p><p>返回给浏览器，去做一个解析。（html/json/xml/jpg/png）</p><p>基于约定，拿到我想要拿到的东西，就是协议。</p><p><img src="'+n+'" alt="请求DNS地址-拿到服务器上的内容"></p><p>实现一个对我们产生作用的网络，必须解决一些问题，为了让这些问题便于管理和模块化。</p><p>基于模块化的东西，设计了两种协议</p><h2 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h2><p>能够检测和恢复IP层提供的主机和主机的通讯中可能发生的报文丢失，重复和错误的情况。解决了数据丢失、重复发送的问题，提供了可以信赖的字节流通道。</p><h2 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h2><p>不可信的协议，不会对协议进行改造修复，提供了一个扩展于IP之上的尽力而为的数据报文服务。能够提供应用之间的工作，而不是主机之间的工作。不会解决数据丢失和重复，和顺序混乱的问题。</p><p>用户输入域名，解析出ip，http请求报文</p><h1 id="深入分析-tcp-ip" tabindex="-1">深入分析 TCP/IP <a class="header-anchor" href="#深入分析-tcp-ip" aria-label="Permalink to &quot;深入分析 TCP/IP&quot;">​</a></h1><p>1） DNS解析</p><p>2） 网关进行数据传输</p><p>3） 路由协议</p><p>4） 握手协议</p><h2 id="dns解析" tabindex="-1">DNS解析 <a class="header-anchor" href="#dns解析" aria-label="Permalink to &quot;DNS解析&quot;">​</a></h2><p>DNS解析得到IP地址，由网关进行数据传输，由路由协议传输到目的端。</p><p>（就像打电话，喂，你好，你好，我是…… 我是…… 就是我们的握手协议）</p><p>​ 握手协议防止了数据包的丢失。</p><p>TCP通过三次握手建立一个可靠的通道。</p><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><p>相当于客户端和服务端进行通信时有三个数据包。</p><p>三个状态：SYN-SEND &gt;&gt; SYN-RCVD &gt;&gt; ESTAB-LISHED</p><p><img src="'+l+'" alt="三次握手SYN攻击"></p><h2 id="syn攻击" tabindex="-1">SYN攻击 <a class="header-anchor" href="#syn攻击" aria-label="Permalink to &quot;SYN攻击&quot;">​</a></h2><p>在短时间内客户端伪造大量不存在的ip地址，发送给服务端</p><p>服务端发送给客户端之后，客户端的确认包一直不发给service，这时候存在大量的连接是空闲的，会消耗我们的资源，导致我们很多正常的请求没有办法进去，因为队列满了。</p><p>TCP协议断开：</p><h2 id="四次挥手协议" tabindex="-1">四次挥手协议： <a class="header-anchor" href="#四次挥手协议" aria-label="Permalink to &quot;四次挥手协议：&quot;">​</a></h2><p>FIN_WAIT_1 CLOSE_WAIT FIN_WAIT2 LAST_WAIT TIME_WAIT.</p><p>客户端请求关闭发送给服务端，服务端发送ACK告诉客户端，我收到你的请求了，然后服务端全部请求处理完毕以后发送FIN到客户端，客户端收到FIN报文以后就代表我可以关闭这个连接了，服务端没有收到ACK，就可以重新传输，客户端在两个生命周期以内没有收到回复，服务端就已经关闭了，客户端也可以关闭了。</p><p><img src="'+s+'" alt="四次挥手协议步骤"></p><p>为什么三次四次：</p><p>​ 接收端接收到报文以后可以直接告诉发送端，我收到你的消息了，</p><p>​ 关闭的时候，服务器知道告诉发送端，你发送的请求我收到了，我要等到连接处理完，才处理完。</p><p>​</p><p>TCP协议，全双工协议。</p><p>发送时间在两个报文的生命周期内，</p><p>协议是建立连接，建立连接之后通讯，针对会话发送数据包，发送数据包，基于这个协议去传输。如果接收方不及时接收的情况，发送方应该是可以调控的。</p><p>如果接收方不及时处理的时候，发送方是可以控制的。</p><h2 id="tcp流量控制" tabindex="-1">TCP流量控制 <a class="header-anchor" href="#tcp流量控制" aria-label="Permalink to &quot;TCP流量控制&quot;">​</a></h2><h2 id="滑动窗口-是一种流量控制技术" tabindex="-1">滑动窗口，是一种流量控制技术， <a class="header-anchor" href="#滑动窗口-是一种流量控制技术" aria-label="Permalink to &quot;滑动窗口，是一种流量控制技术，&quot;">​</a></h2><p>为什么用滑动窗口</p><ol><li><p>保证数据不会丢失</p></li><li><p>网络拥塞的情况下会存在数据阻塞</p></li></ol><p>所以在这样的情况下，引入了滑动窗口，去对我们的流量去做一个整形</p><p>动态地址：</p><p><a href="http://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="noreferrer">http://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html</a></p><p><img src="'+h+'" alt="发送端-接收端-TCP缓冲区"></p><p>缓冲区是有大小的，控制流量，</p><p>缓冲区的大小就是窗口大小，发送消息，收到ack以后就可以发送下一个窗口</p><p>可以设置缓冲区的大小。</p><p>根据接收端的缓冲区可以动态调整窗口大小，</p><p>发送窗口，允许发送的数据帧的数据量的大小，</p><p>接收窗口，</p><p>没有收到消息，会重新发，</p><p><img src="'+c+'" alt="TCP缓冲区发送缓冲区"></p><p><img src="'+d+'" alt="TCP缓冲区发送接收"></p><p><img src="'+P+'" alt="TCP缓冲区发送接收ACK"></p><p><img src="'+m+'" alt="TCP缓冲区发送继续发送"></p><p><img src="'+b+'" alt="TCP缓冲区发送再次发送"></p><h1 id="使用tcp协议进行通讯" tabindex="-1">使用TCP协议进行通讯 <a class="header-anchor" href="#使用tcp协议进行通讯" aria-label="Permalink to &quot;使用TCP协议进行通讯&quot;">​</a></h1><p>协议层之上就是应用，协议这块会很复杂</p><p>在现在的编程语言中，提供很完整的机制，屏蔽复杂过程，便于开发应用程序</p><p>TCP、UDP都是基于socket概念上为某一个应用场景扩展出来的协议。</p><h2 id="什么是socket" tabindex="-1">什么是Socket <a class="header-anchor" href="#什么是socket" aria-label="Permalink to &quot;什么是Socket&quot;">​</a></h2><p>socket可以认为是一个抽象层，应用程序通过它来发送和接收消息。</p><p>这个时候通过应用程序打开文件句柄，读取数据磁盘，或者把数据写入到磁盘上。</p><p>使用socket可以把我们的应用程序添加到网络上，而且能跟和它处于一个网络的应用去通信，这就是socket。</p><p>不同的类型的socket和底层的协议是有关系的。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Stream socket（TCP）</td><td>字节流</td></tr><tr><td>datagram socket （UDP）</td><td>数据报文</td></tr></tbody></table><p><img src="'+u+'" alt="APP通过Socket和服务端通信"></p><p>Socket 套接字。</p><p>基于socket 选择协议（TCP [1-65535端口] UDP），然后带上IP（基于IP协议）</p><p>Netty是一个基于NIO的框架</p><p>TCP协议是一个全双工的协议</p><h1 id="bio" tabindex="-1">BIO <a class="header-anchor" href="#bio" aria-label="Permalink to &quot;BIO&quot;">​</a></h1><p><img src="'+_+'" alt="Client-Server-BIO图解"></p><p>BIO 是一个客户端请求分配一个线程</p><p><img src="'+k+'" alt="Client-Server-BIO图解-Server-Thread"></p><h2 id="bio-阻塞" tabindex="-1">BIO 阻塞 <a class="header-anchor" href="#bio-阻塞" aria-label="Permalink to &quot;BIO 阻塞&quot;">​</a></h2><p>缓冲区被占用</p><p>TCP协议是一个基于缓冲区，内核里边都会有个发送缓冲区，接收缓冲区，TCP的全双工模式是以TCP的滑动窗口，和依赖于这两个独立的缓冲区的填充状态，去处理的， 接收缓冲区把数据缓存到内核里边，如果说应用程序，没有调用read方法去读取的话，就会存在我们的接收缓冲区里边，这个缓冲区都不会被清理掉。</p><p>我们接收端receive去调用read去读取数据，实际上就是把内核读取到的数据复制到我们应用程序的buffer里边，再做一个处理。</p><p>进程里边调用socket去发送数据</p><p><img src="'+I+'" alt="TCP-发送端-接收端-TCP缓冲区"></p><p>在IO层存在一个IO的调度线程去不断扫描Socket缓冲区。</p><p>发现写某个写入缓冲区为空，扫描到了就可以产生一个socket可写事件，我们的程序就可以对数据进行socket写入。如果一次写入没有写完，等下次写入再去写。</p><p>（Epoll Selector机制）</p><p>当接收端发现socket接收缓冲区有数据时，会产生socket可读事件，即使缓冲区满了，我也可以去接收其他请求。</p><p>有一个事件通知，可以读取这个数据</p><h1 id="nio-1" tabindex="-1">NIO <a class="header-anchor" href="#nio-1" aria-label="Permalink to &quot;NIO&quot;">​</a></h1><p>​ 发现你不可写，会有一个事件通知，我这个事件告诉你什么时候可以写了，然后我就可以去调用，去做一个处理消息的过程。</p><p>​ 就是 Epoll 和 Selector 模型的概念。</p><p>​ New IO或者no black IO;</p><p>NIO 非阻塞通信 （Non-blocking I/O，在Java领域，也称为New I/O）</p><p>通过一个事件机制，实现解耦</p><p>多路复用基于的是NIO机制。</p><ul><li>客户端：都注册一个channel</li><li>客户端：都注册一个channel</li></ul><p>NIO以多路复用为基础。服务端有一个多路复用器，轮询每一个channel。选择一个具备已经能够运行任务的能力的channel。如果某个注册上来的channel上的TCP产生了一个可写事件的话，那么就能够被轮询出来，去做一个执行。如果满足状态，执行相应的机制，然后不断地轮询。</p><p><img src="'+f+'" alt="Client-Server-NIO图解"></p><p>产生socket可写事件</p><h1 id="组播协议" tabindex="-1">组播协议 <a class="header-anchor" href="#组播协议" aria-label="Permalink to &quot;组播协议&quot;">​</a></h1><h2 id="单播协议" tabindex="-1">单播协议 <a class="header-anchor" href="#单播协议" aria-label="Permalink to &quot;单播协议&quot;">​</a></h2><p>TCP UDP 都是基于点对点的通讯， 可以称为单播协议。</p><h2 id="广播" tabindex="-1">广播 <a class="header-anchor" href="#广播" aria-label="Permalink to &quot;广播&quot;">​</a></h2><p>网络中的所有的主机都可以收到一份数据副本</p><h2 id="多播" tabindex="-1">多播 <a class="header-anchor" href="#多播" aria-label="Permalink to &quot;多播&quot;">​</a></h2><p>消息只发送给一个多播地址，网络会把数据发送给那些想要监听的主机</p><p>只有订阅了这个感兴趣的主机才能收到</p><p>​</p><h3 id="广播-1" tabindex="-1">广播： <a class="header-anchor" href="#广播-1" aria-label="Permalink to &quot;广播：&quot;">​</a></h3><p>子网主机发送消息，子网内的主机都能收到信息</p><p>​</p><p>NIO是基于IO的更好性能的技能</p><p>Java本身提供了NIO技术，netty基于NIO做了一个封装，提供了一个更优化的功能而已。</p>',182),q=[T];function g(E,v,A,x,S,N){return e(),t("div",null,q)}const J=a(C,[["render",g]]);export{B as __pageData,J as default};

import{_ as e,o as a,h as p,Q as s}from"./chunks/framework.da611722.js";const o="/assets/JavaGuide_Zookeeper_核心原理_由来.7b864b16.png",r="/assets/JavaGuide_Zookeeper_核心原理_目录特性结构.c5b33d3f.png",l="/assets/JavaGuide_Zookeeper_核心原理_协调者_参与者.a7dd086a.png",n="/assets/JavaGuide_Zookeeper_核心原理_协调者_Client_Leader_Follower_Observer.a82c25ea.png",t="/assets/JavaGuide_Zookeeper_核心原理_Zxid消息_原理.45854ccc.png",i="/assets/JavaGuide_Zookeeper_核心原理_如何保证消息不丢失.d8a86643.png",c="/assets/JavaGuide_Zookeeper_核心原理_被丢弃的消息不能再出现.bc527b22.png",d="/assets/JavaGuide_Zookeeper_核心原理_Zxid的日志.a58e7da8.png",h="/assets/JavaGuide_Zookeeper_核心原理_理解Zab协议.4a44b5a9.png",u="/assets/JavaGuide_Zookeeper_核心原理_Leader_Looking_日志.2d619fb9.png",m="/assets/JavaGuide_Zookeeper_核心原理_投票的过程.3c329ffa.png",Z=JSON.parse('{"title":"了解zookeeper的核心原理 | JavaGuide","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://javaguide.net/百万架构师/协调服务-zookeeper/了解zookeeper的核心原理.html"}],["meta",{"name":"keywords","content":"了解zookeeper的核心原理 , JavaGuide , JavaGuide官网, Java面试指南, Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"了解zookeeper的核心原理 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"og:description","content":"了解zookeeper的核心原理 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://javaguide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"了解zookeeper的核心原理 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"twitter:description","content":"了解zookeeper的核心原理 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"sogou_site_verification","content":"fcAkazTXFd"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/协调服务-zookeeper/了解zookeeper的核心原理.md","filePath":"百万架构师/协调服务-zookeeper/了解zookeeper的核心原理.md","lastUpdated":1741277271000}'),b={name:"百万架构师/协调服务-zookeeper/了解zookeeper的核心原理.md"},k=s(`<ol><li><p>了解zookeeper及zookeeper的设计猜想</p></li><li><p>Zookeeper集群角色</p></li><li><p>深入分析ZAB协议</p></li><li><p>从源码层面分析leader选举的实现过程</p></li><li><p>关于zookeeper的数据存储</p></li></ol><h1 id="回顾内容" tabindex="-1">回顾内容 <a class="header-anchor" href="#回顾内容" aria-label="Permalink to &quot;回顾内容&quot;">​</a></h1><ol><li><pre><code> zookeeper集群安装（myid/zoo.cfg）
</code></pre></li><li><pre><code> zookeeper的数据模型（znode）
</code></pre></li><li><pre><code> 节点的特性
</code></pre></li></ol><p>（持久化、临时节点、有序节点、同级节点必须唯一、临时节点不能存在子节点）</p><ol start="4"><li><pre><code> 节点的status信息
</code></pre></li><li><pre><code> 简单地了解了watcher机制
</code></pre></li><li><pre><code> Zookeeper的应用场景
</code></pre></li></ol><h1 id="zookeeper的由来" tabindex="-1">Zookeeper的由来 <a class="header-anchor" href="#zookeeper的由来" aria-label="Permalink to &quot;Zookeeper的由来&quot;">​</a></h1><p><img src="`+o+`" alt="JavaGuide_Zookeeper_核心原理_由来.png"></p><p>分布式架构下面临的问题</p><p>我们有一个 orderservice 服务</p><p>我们对同一个应用去做拷贝，相当于是部署了三个一模一样的应用实例，组成一个集群。每个模块中运行一个 Task 任务。</p><p>因为我们是一个集群，所以我们每一个节点都有权限去执行这个任务。</p><p>我们每一个服务都会有一个配置文件，application.properties，配置文件中会配置一些数据库的信息，连接信息，服务地址信息等等，我们可能有些东西是需要动态变更的，这是一个背景，然后这些数据需要进行调整的话，因为现在是一个集群，所以现在必须在同一时刻，对这些数据进行一个更新，但是如果你是保存在配置文件里边的话，你怎么保证各个节点的数据保持一致。</p><p>我们现在一个server执行一个任务，假如说 ，这个任务在server1上执行，怎么控制这个任务只在server1上执行。假如说我们有一个定时任务解析文件去入库，我们怎么只让其中一台机子去解析这个文件，其他机子不需要解析。因为如果三台机子都做这个任务的话，那么意味着数据要做三次。</p><p>如果你有一个手段让一个任务只在一个server上执行，如果其中一个服务挂掉了以后，其他节点怎么知道它挂掉了，去重新接替任务。</p><p>我们如果说存在一个共享资源，集群对每一个节点都是公平的，所以存在某一个时刻，很多个服务去访问同一个文件。在访问的时候怎么去保证互斥性，就像多线程里边，多个线程同时访问同一块资源，如果保证线程资源的安全性。</p><h1 id="集中式到分布式架构发展带来的问题" tabindex="-1">集中式到分布式架构发展带来的问题： <a class="header-anchor" href="#集中式到分布式架构发展带来的问题" aria-label="Permalink to &quot;集中式到分布式架构发展带来的问题：&quot;">​</a></h1><ol><li><pre><code> 各个数据节点的数据一致
</code></pre></li><li><pre><code> 怎么保证任务只在一个节点上执行。
</code></pre></li><li><pre><code> 如果某个节点挂了，其他节点如果发现并接替执行任务。
</code></pre></li><li><pre><code> 存在共享资源的场景。互斥性、安全性
</code></pre></li></ol><p>总结一下，就是缺少一个分布式的协调机制。</p><p>分布式协调做得比较好的一个是</p><ol><li><pre><code> 谷歌的chubby
</code></pre></li><li><pre><code> Apache的zookeeper
</code></pre></li></ol><p>谷歌的chubby是一个分布式锁的东西，</p><p>解决分布式锁、master选举相关的服务</p><p>雅虎公司内部很多模块，它需要依赖一个系统，去对里边的分布式系统去做一个协调，然而Google的chubby不开源。 所以雅虎基于chubby的思想开发了zookeeper，捐献给Apache，所以现在我们下载的zookeeper是从Apache上下载下来的。</p><h2 id="这就是我们为什么要用zookeeper机制的原因-。" tabindex="-1">这就是我们为什么要用zookeeper机制的原因 。 <a class="header-anchor" href="#这就是我们为什么要用zookeeper机制的原因-。" aria-label="Permalink to &quot;这就是我们为什么要用zookeeper机制的原因 。&quot;">​</a></h2><p><img src="`+r+`" alt="JavaGuide_Zookeeper_核心原理_目录特性结构.png"></p><p>Zookeeper，是一个文件结构的树形结构的数据存储，我们基于zookeeper本身的数据结构和它的节点特性，我们可以利用它去实现一个，互斥的访问</p><p>那么我们就需要先去注册一个结点，因为zookeeper节点是一个树形结构</p><p>我们把zookeeper中最小的那个节点有优先权，第一个服务去执行，后边的两个就不让它去执行。我们利用zookeeper起到对我们相关服务节点的协调控制。</p><p>如果我们的zookeeper作为我们整个系统的服务协调中心的话，那么zookeeper就会成为一个瓶颈，而zookeeper目标是提供一个高性能，高可用的，有严格访问顺序的控制能力（表示写操作的顺序）分布式协调服务。</p><h2 id="初衷" tabindex="-1">初衷 <a class="header-anchor" href="#初衷" aria-label="Permalink to &quot;初衷&quot;">​</a></h2><p>基于zookeeper的初衷，我们要解决zookeeper的性能问题。</p><p>还有它本身的可用性，我们不能让它本身成为一个单点。如果它是一个单点，如果它挂了，那么相应的节点无法执行相应的操作。</p><h2 id="zookeeper的设计猜想" tabindex="-1">Zookeeper的设计猜想： <a class="header-anchor" href="#zookeeper的设计猜想" aria-label="Permalink to &quot;Zookeeper的设计猜想：&quot;">​</a></h2><ol><li><pre><code> 防止单点故障
</code></pre></li></ol><p>集群方案（leader、follower）、还能分担请求</p><ol start="2"><li><pre><code> 每个节点的数据是一致的（必须要有leader）
</code></pre></li></ol><p>​ Leader、master； redis-cluster</p><ol start="3"><li><pre><code> Leader挂了怎么办？数据如何恢复
</code></pre></li></ol><p>​ 选举机制？数据如何恢复</p><ol start="4"><li><pre><code> 如何去保证数据一致性？(分布式事务)
</code></pre></li></ol><p>​ 一开始单体架构中，CAP一致性是由一个事务去统一控制和管理的，现在一个请求，分到了不同的服务器，但是我还需要保证在整个集群是一致的。</p><p>​ 每个节点只能保证内部的一致性，我们要保证整体的一致性，zookeeper就引入了改进版的2PC协议去完成2阶提交</p><p>2PC 二阶段提交协议</p><p>Two Phase Commitment Protocol</p><p>当一个事务涉及多个节点去提交的时候，为了保证事务处理的ACI的特性的话，在2PC中引入了一个概念叫协调者，通过一个协调者来控制各个节点事务的执行逻辑。</p><p><img src="`+l+`" alt="JavaGuide_Zookeeper_核心原理_协调者_参与者.png"></p><p>如果参与者1与参与者2中的数据需要都执行成功，才算一次完整的成功。</p><p>在单体架构中直接通过transactional去直接控制事务的一致性。</p><p>在分布式系统中引入一个协调者，协调者先对每一个参与这个事务的参与者提交一次请求，每个参与者收到请求后，会给一个回应，是不是能够执行这个事务，给个“是”，表示可以执行这次事务，如果每一个参与者都回应一个是，那么就表示这个请求是可以被执行成功的。 这时候协调者就对每一个参与者进行一次commit，然后提交完成以后给一个ack的二阶提交的响应。</p><p>假如某一个参与者第一次回应了一个“否”，就意味着整体要全部失败，事务要保证原子性，要么全部成功，要么全部失败。那么对所有的节点发起的是一个rollback操作。这就是一个所谓的二阶段提交的概念。</p><p>而zookeeper里边是基于二阶提交的方式去做数据同步的</p><h2 id="结论" tabindex="-1">结论： <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论：&quot;">​</a></h2><ol><li><pre><code> 为什么用ZAB实现选举（基于proposal思想的，zookeeper里边的协议，解决数据一致性的问题）
</code></pre></li><li><pre><code> 为什么要做集群
</code></pre></li><li><pre><code> 为什么通过2PC做数据一致性
</code></pre></li></ol><h1 id="zookeeper的集群" tabindex="-1">Zookeeper的集群 <a class="header-anchor" href="#zookeeper的集群" aria-label="Permalink to &quot;Zookeeper的集群&quot;">​</a></h1><p>我们现在有一个客户端，对zookeeper集群做出了一个处理</p><p>Zookeeper对外有一个集群，客户端进行连接这个集群时，会随机连接某一个节点。</p><p>如果当前的请求是读请求，我们的请求可以落在任意一个节点去读取数据。</p><p>如果是写请求，那么这个请求会转发给leader去处理</p><p>我们说过了，zookeeper是基于一个2PC的方式进行的一个事务的提交</p><p>如果我们的一个写请求到了一个follower节点上，它会转发到leader节点上，然后leader节点会发起一个提议，会把事务发给集群中的每一个节点，这时候的follower节点要给leader节点一个ack，这个ack表示当前的这个节点是不是能够执行这个事务，leader一旦发现过半的请求是同意的，我会提交这个事务，然后就返回response。</p><p>这就是改进版的2PC的一个事务。然后提交事务以后，数据会同步给observer。</p><p><img src="`+n+'" alt="JavaGuide_Zookeeper_核心原理_协调者_Client_Leader_Follower_Observer.png"></p><p>Leader是整个zookeeper集群的核心，起到了主导zookeeper集群的一个作用，比如说我们一个事务请求的一个调度和处理，保证我们集群中事务处理的一个顺序性。</p><p>Follower角色主要是用来处理客户端的非事务请求，以及转发事务请求给leader服务器，参与整个事务的投票过程，叫proposal，我们这条数据要保存到zookeeper集群里边，必须要有过半的节点同意。</p><p>Observer是一个观察者的角色，相当于我能够了解集群中相关节点的相关变化并且对状态进行同步， observer不参与事务请求的投票。</p><p>如果我们想要集群的性能更高，我们肯定想要引入更多的节点，节点越来越多，性能提升了，投票的时候会变慢，不影响整体写性能的情况下，引入observer，提升整体的性能。</p><p>所有节点的数量必须是2N+1，我们必须保证有2N+1个节点，叫基础节点，zookeeper集群的工作机制，是必须有半数以上节点能够正常地工作，并且能够参与到投票机制，如果投票不能过半的话，我们的投票是没有结果的。</p><h2 id="zab协议" tabindex="-1">ZAB协议 <a class="header-anchor" href="#zab协议" aria-label="Permalink to &quot;ZAB协议&quot;">​</a></h2><p>​ （基于Proposal协议衍生出来的一种算法）</p><p>ZAB协议是zookeeper里边专门设计的针对崩溃恢复的原子广播协议，</p><p>主要用来实现数据一致性</p><p>Zookeeper是一种类似于主备的形式，leader挂了，follower上能够选举出一个leader来，代替上一个leader上的服务，通过ZAB协议保证各个节点上数据的一致性，为了保证主备数据的一致性，就需要实现ZAB协议。</p><ul><li>崩溃恢复</li><li>原子广播</li></ul><p>当我们第一次启动集群的时候或者leader集群崩溃的时候，这时候ZAB协议就会产生作用，ZAB协议会进入恢复模式，它会从宕掉的集群里边重新去选举一个leader，并且当新的leader选举出来以后，当集群中过半的机器和新选举的leader完成了数据同步以后，整个集群就进入了一个正常运行的状态，就进入了一个原子广播的阶段。</p><h2 id="消息广播-事务提交" tabindex="-1">消息广播：（事务提交） <a class="header-anchor" href="#消息广播-事务提交" aria-label="Permalink to &quot;消息广播：（事务提交）&quot;">​</a></h2><p><img src="'+t+`" alt="JavaGuide_Zookeeper_核心原理_Zxid消息_原理.png"></p><p>​ 改进版本的2PC</p><p>首先当leader收到一个事务请求的时候会生成一个zxid(64位的自增ID)</p><ol><li><pre><code> 它会对每一个请求分配一个zxid，
</code></pre></li></ol><p>通过zxid的大小可以实现数据的因果有序</p><p>Leader对每一个follower都会准备一个IFIO队列，这个是通过TCP协议来实现的，</p><ol start="2"><li><pre><code> 它会把带有zxid的消息作为一个proposal（提案），分发到集群中的每一个follower节点
</code></pre></li><li><pre><code> 每一个follower节点收到请求以后，它会把propose这个事务写入到磁盘，返回ack给leader
</code></pre></li><li><pre><code> Leader收到合法数量的请求ack，过半的请求数，同意以后，再发起commit请求
</code></pre></li></ol><p>整个事务的过程就是一个消息广播的过程。</p><p>Leader的投票过程和事务的投票过程中不需要observer，但是observer必须保证他的数据和leader的数据是保持一致的</p><h2 id="崩溃恢复-对数据层来说" tabindex="-1">崩溃恢复（对数据层来说） <a class="header-anchor" href="#崩溃恢复-对数据层来说" aria-label="Permalink to &quot;崩溃恢复（对数据层来说）&quot;">​</a></h2><ol><li><p>当leader失去了过半的follower节点的联系</p></li><li><p>当leader服务挂了</p></li></ol><p>整个集群就会进入崩溃恢复阶段，因为我们必须保证leader挂了之后整个集群还可用。</p><p>对于数据恢复来说：</p><ol><li><pre><code> 已经被处理的消息不能丢失
</code></pre></li></ol><p><img src="`+i+`" alt="JavaGuide_Zookeeper_核心原理_如何保证消息不丢失.png"></p><p>​ 当leader收到合法数量的follower的ack以后，就会向各个follower广播消息（commit命令），同时本地自己也会commit这条事务消息。如果follower节点收到commit命令之前，Leader挂了。会导致部分节点收到commit，部分节点没有收到commit。ZAB协议需要保证已经处理的消息不能丢失。</p><ol start="2"><li><pre><code> 被丢弃的消息不能再次出现
</code></pre></li></ol><p><img src="`+c+`" alt="JavaGuide_Zookeeper_核心原理_被丢弃的消息不能再出现.png"></p><p>​ 当leader请求收到事务请求，并且还未发起事务投票之前，leader挂了。</p><p>下一个leaser，要跳过这个请求。</p><p>我们的leader挂掉以后，我们不仅需要重新选举leader，还要恢复我们的数据。</p><h3 id="zab的设计思想" tabindex="-1">ZAB的设计思想 <a class="header-anchor" href="#zab的设计思想" aria-label="Permalink to &quot;ZAB的设计思想&quot;">​</a></h3><ol><li><pre><code> zxid是最大的？   保证已经提交的proposal一定会被提交！！不会出现数据丢失。
</code></pre></li><li><pre><code> epoch的概念，每产生一个新的leader，那么新的leader的epoch会+1
</code></pre></li></ol><p>​ zxid是64位的数据，</p><p>低32位表示消息计数器（自增的），高32位（epoch编号）</p><p>如果我们新的选举出来的leader，就意味着它的epoch比老的epoch高，它的每一个事务id 都会带上epoch编号，和消息计数器。这样设计以后，当我们重新选举leader以后，消息会重新从0开始，而epoch是老的加上一，好处是：老的服务器重新启动以后，它不会再成为leader，就是在这一轮里边不会在成为leader，并且老的leader，变成follower，加入到集群以后，它的zxid一定会小于新的zxid，那么新的leader，会把他所有没有提交的事务都会清除。</p><p>epoch可以理解为年号，皇帝的年号。</p><h1 id="实操" tabindex="-1">实操 <a class="header-anchor" href="#实操" aria-label="Permalink to &quot;实操&quot;">​</a></h1><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# ls /tmp/zookeeper/</span></span>
<span class="line"><span style="color:#B392F0;">myid</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">version-2</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">zookeeper_server.pid</span></span>
<span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# ls /tmp/zookeeper/version-2/</span></span>
<span class="line"><span style="color:#B392F0;">acceptedEpoch</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">currentEpoch</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">log.1</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">log.100000001</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">log.200000001</span></span>
<span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# vim /tmp/zookeeper/version-2/currentEpoch </span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">2</span></span>
<span class="line"><span style="color:#F97583;">~</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[root@Darian1 bin]# ls /tmp/zookeeper/</span></span>
<span class="line"><span style="color:#6F42C1;">myid</span><span style="color:#24292E;">  </span><span style="color:#032F62;">version-2</span><span style="color:#24292E;">  </span><span style="color:#032F62;">zookeeper_server.pid</span></span>
<span class="line"><span style="color:#24292E;">[root@Darian1 bin]# ls /tmp/zookeeper/version-2/</span></span>
<span class="line"><span style="color:#6F42C1;">acceptedEpoch</span><span style="color:#24292E;">  </span><span style="color:#032F62;">currentEpoch</span><span style="color:#24292E;">  </span><span style="color:#032F62;">log.1</span><span style="color:#24292E;">  </span><span style="color:#032F62;">log.100000001</span><span style="color:#24292E;">  </span><span style="color:#032F62;">log.200000001</span></span>
<span class="line"><span style="color:#24292E;">[root@Darian1 bin]# vim /tmp/zookeeper/version-2/currentEpoch </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">2</span></span>
<span class="line"><span style="color:#D73A49;">~</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># ls /tmp/zookeeper/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># ls /tmp/zookeeper/version-2/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">acceptedEpoch</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">cuttentEpoch</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">log.1</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">log.1000000001</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">log.3</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">log.a00000001</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># ls /tmp/zookeeper/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># ls /tmp/zookeeper/version-2/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">acceptedEpoch</span><span style="color:#24292E;"> </span><span style="color:#032F62;">cuttentEpoch</span><span style="color:#24292E;"> </span><span style="color:#032F62;">log.1</span><span style="color:#24292E;"> </span><span style="color:#032F62;">log.1000000001</span><span style="color:#24292E;"> </span><span style="color:#032F62;">log.3</span><span style="color:#24292E;"> </span><span style="color:#032F62;">log.a00000001</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;"># vim /tmp/zookeeper/version-2/currentEpoch</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;"># vim /tmp/zookeeper/version-2/currentEpoch</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>可以看到epoch</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">:q!</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">:q!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="epoch" tabindex="-1">Epoch <a class="header-anchor" href="#epoch" aria-label="Permalink to &quot;Epoch&quot;">​</a></h2><p>我们去关闭leader</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# sh zkServer.sh stop</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[root@Darian1 bin]# sh zkServer.sh stop</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>重新看到epoch</p><p>可以看到加了一</p><p>Epoch加一，可以保证把以前没有提交的proposal丢弃掉，</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# ls /tmp/zookeeper/version-2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[root@Darian1 bin]# ls /tmp/zookeeper/version-2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>查看日志内容</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[root@Darian1 bin]# java -cp :/zookeeper/zookeeper-3.4.10/lib/slf4j-api-1.6.1.jar:/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.jar org.apache.zookeeper.server.LogFormatter /tmp/zookeeper/version-2/log.1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">路径：java</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">–cp</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">:/slf4j.jar:/zookeeper.jar</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">org.apache.zookeeper.server.LogFormatter</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">/tmp/zookeeper/version-2/log.1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[root@Darian1 bin]# java -cp :/zookeeper/zookeeper-3.4.10/lib/slf4j-api-1.6.1.jar:/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.jar org.apache.zookeeper.server.LogFormatter /tmp/zookeeper/version-2/log.1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">路径：java</span><span style="color:#24292E;"> </span><span style="color:#032F62;">–cp</span><span style="color:#24292E;"> </span><span style="color:#032F62;">:/slf4j.jar:/zookeeper.jar</span><span style="color:#24292E;">  </span><span style="color:#032F62;">org.apache.zookeeper.server.LogFormatter</span><span style="color:#24292E;"> </span><span style="color:#032F62;">/tmp/zookeeper/version-2/log.1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="`+d+`" alt="JavaGuide_Zookeeper_核心原理_Zxid的日志.png"></p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">server.1</span><span style="color:#E1E4E8;">=192.168.136.128:2888:3888</span></span>
<span class="line"><span style="color:#B392F0;">server.2</span><span style="color:#E1E4E8;">=192.168.136.129:2888:3888</span></span>
<span class="line"><span style="color:#B392F0;">server.3</span><span style="color:#E1E4E8;">=192.168.136.130:2888:3888</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">server.1</span><span style="color:#24292E;">=192.168.136.128:2888:3888</span></span>
<span class="line"><span style="color:#6F42C1;">server.2</span><span style="color:#24292E;">=192.168.136.129:2888:3888</span></span>
<span class="line"><span style="color:#6F42C1;">server.3</span><span style="color:#24292E;">=192.168.136.130:2888:3888</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="理解zab协议" tabindex="-1">理解ZAB协议 <a class="header-anchor" href="#理解zab协议" aria-label="Permalink to &quot;理解ZAB协议&quot;">​</a></h1><p><img src="`+h+'" alt="JavaGuide_Zookeeper_核心原理_理解Zab协议.png"></p><p>假设leader中有三个事务请求</p><table><thead><tr><th></th><th>zxid</th></tr></thead><tbody><tr><td>P1</td><td>01</td></tr><tr><td>P2</td><td>02</td></tr><tr><td>P3</td><td>03</td></tr></tbody></table><p>它会把这个事务分发给每一个节点去做提交</p><p>假设</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Follower1</td><td>收到了 p1 01</td></tr><tr><td>Follower2</td><td>收到了 p1 01</td></tr></tbody></table><p>其他请求还没有发起，</p><p>这时候leader挂了，</p><p>这时候我们假设follower1变成了leader</p><p>这时候新的leader发起了一个新的事务请求，</p><p>[p2] -10</p><p>（代表epoch 0 代表消息数）</p><p>这个请求同步到follower上 叫 [p2] -10</p><h2 id="数据恢复" tabindex="-1">数据恢复 <a class="header-anchor" href="#数据恢复" aria-label="Permalink to &quot;数据恢复&quot;">​</a></h2><p>整个集群里边所有的参与者follower节点都要确定事务日志里边的Propress已经被过半的节点提交过了。</p><p>Leader会为每一个follower节点准备一个FIFO的队列，把各个follower节点没有被提交的请求，以事务的方式逐步发给其他节点，但是，如果事务是失效的，过期的，它会被丢弃掉。</p><h1 id="leader选举" tabindex="-1">Leader选举 <a class="header-anchor" href="#leader选举" aria-label="Permalink to &quot;Leader选举&quot;">​</a></h1><p>两种情况会做leader选举，</p><p>一个是集群启动，一个是崩溃恢复</p><p>Fast Leader 基于fast leader做选举的</p><p>Zxid最大会设置为leader【事务id，事务id越大，那么表示数据越新】</p><p>​ 64位， 000000000000000001（epoch） 0000000000000000000010</p><p>Myid（服务器id,sid）【myid越大，在leader选举机制中权重越大】</p><p>epoch【逻辑时钟】【每一轮投票，epoch都会递增】</p><h3 id="选举状态-looking" tabindex="-1">选举状态（LOOKING） <a class="header-anchor" href="#选举状态-looking" aria-label="Permalink to &quot;选举状态（LOOKING）&quot;">​</a></h3><ul><li>LEADING</li><li>FOLLOWING</li><li>OBSERVING</li></ul><h3 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h3><p>启动的时候初始化，每一个节点会选举自己作为一个leader，把当前节点的这些信息发布给集群中的每一个节点。</p><p>（myid, zxid, epoch）</p><p>每一个节点会收到这些信息，然后去做投票。投票过程中会比较对应的数据记录结果。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>检查zxid</td><td>zxid大的节点直接为leader</td></tr><tr><td>2</td><td>myid</td><td>myid比较大的会作为leader</td></tr><tr><td>3</td><td>投票完了以后</td><td>会去统计票数，根据投票结果，确定leader选举的结果。</td></tr><tr><td>4</td><td>统计投票</td><td>每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接收到相同的投票信息，此时便认为已经选出了Leader</td></tr></tbody></table><p>如果运行过程中的选举的话，leader挂掉了，它可以重新去选举leader，第一个它会去变更状态，把剩下的所有节点都变成一个LOOKING状态去重新做一个监控，监控其他的节点去重新做一个选举。 接下来步骤跟初始化的都一样了………</p><p>zookeeper 的代码入口搜索 QuorumPeerMain</p><p>FastLeaderElection 类中 的 lookForLeader投票方法的实现机制</p><p><img src="'+u+'" alt="JavaGuide_Zookeeper_核心原理_Leader_Looking_日志.png"></p><h2 id="投票流程" tabindex="-1">投票流程 <a class="header-anchor" href="#投票流程" aria-label="Permalink to &quot;投票流程&quot;">​</a></h2><p><img src="'+m+`" alt="JavaGuide_Zookeeper_核心原理_投票的过程.png"></p><ol><li><pre><code> 判断epoch
</code></pre></li><li><pre><code> Zxid
</code></pre></li><li><pre><code> 再判断myid
</code></pre></li></ol><p>高性能和高可用的集群</p><p>热备的集群</p>`,160),v=[k];function y(_,g,E,z,F,f){return a(),p("div",null,v)}const J=e(b,[["render",y]]);export{Z as __pageData,J as default};

import{_ as a,o as e,h as n,Q as p}from"./chunks/framework.da611722.js";const i="/assets/Spring手画架构图.73eed4aa.png",r="/assets/Spring官方架构图.3bf75e71.jpg",B=JSON.parse('{"title":"Spring5源码分析-预习资料 | Java面试指南","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://javaguide.net/百万架构师/Spring 源码分析/预习资料/Spring5源码分析-预习资料.html"}],["meta",{"name":"keywords","content":"Spring5源码分析-预习资料 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"Spring5源码分析-预习资料 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"og:description","content":"Spring5源码分析-预习资料 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://javaguide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"Spring5源码分析-预习资料 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"twitter:description","content":"Spring5源码分析-预习资料 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/Spring 源码分析/预习资料/Spring5源码分析-预习资料.md","filePath":"百万架构师/Spring 源码分析/预习资料/Spring5源码分析-预习资料.md","lastUpdated":1740370683000}'),t={name:"百万架构师/Spring 源码分析/预习资料/Spring5源码分析-预习资料.md"},o=p('<h1 id="三、spring5-概述" tabindex="-1">三、Spring5 概述 <a class="header-anchor" href="#三、spring5-概述" aria-label="Permalink to &quot;三、Spring5 概述&quot;">​</a></h1><p>Spring 是一个开源的轻量级 Java SE （Java 标准版本）/ Java EE （Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完成的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且低耦合，高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们创建对象及管理这些对象之间的依赖关系。可能有人说了“抽象工厂、工厂方法设计模式”也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些我们有需要创建类一些工厂类、生成器类，我们又要额外地管理这些类，增加我们的负担。如果能有一种通过配置方式来创建对象，管理对象之间的依赖关系。我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发速度，能节省出很多时间来做其他事。Spring 框架刚出来的时候主要就是来完成这个功能。</p><p>Spring 框架除了帮我们管理对象及依赖关系，还提供通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我们管理最头疼的数据库事务，本身提供了一套简单的 JDBC 访问实现，提供与第三方数据访问框架的集成（如 Hibernate、JPA），与各种 Java EE （c/s 架构）应用程序还是 JAVA EE（B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下Spring 到底帮我们做些什么？</p><h2 id="_3-1、一切从-bean-开始" tabindex="-1">3.1、一切从 Bean 开始 <a class="header-anchor" href="#_3-1、一切从-bean-开始" aria-label="Permalink to &quot;3.1、一切从 Bean 开始&quot;">​</a></h2><p>1996，Java 还只是一个新兴的、初出茅庐的编程语言。人们之所以关注她仅仅是因为，可以使用 Java 的 Applet 来开发 Web 应用。但这些开发者很快就发现这种新型的语言还能做更多的事情。与之前的所有语言不同，Java 让模块化构建复杂的系统成为可能（当时的软件行业虽然在业务上突飞猛进，但是开发用的是传统的面向过程开发思想，软件的开发效率一直止步不前。伴随着业务复杂性的不断加深，开发也变得越发困难。其实，当时也是面向对象思想飞速发展的时期，她在 80 年代末被提出，成熟于 90 年代，现今大多数编程语言都是面向对象的，当然这是后话了）。他们为 Applet 而来，为组件化而来，这便是最早的 Java。</p><p>同样在这一年的 12 月，Sun 公司发布了还名不经传但后来人尽皆知的 JavaBean 1.00-A 规范。早期的 JavaBean 规范针对于 Java ，她还定义了软件组件模型。这个规范规定了一整套编码策略，使简单的 Java 对象不仅可以被重用，而且还可以轻松地构建更为复杂的应用。尽管 JavaBean 最初是为了重用应用组件而设计的，但当时他们却是主要用作构建窗体控件，毕竟在 PC 时代那才是主流。但相比于当时正如日中天的 Delphi、VB 和 C++，他看起来还是太简易了，以至于没法胜任任何“实际性”的工作。</p><p>复杂的应用通常需要诸如事务、安全、分布式等服务的支持，但 JavaBean 并未直接提供。所以到了 1998 年 3 月，Sun 发布了 EJB 1.0 规范，该规范把 Java 组件的设计理念延伸到了服务器端，并提供了许多必需的企业级服务，但他也不再像早期的 JavaBean 那么简单了。实际上，除了名字，EJB Bean 已经和 JavaBean 没有任何关系了。</p><p>尽管现实中有很多系统是基于 EJB 构建的，但 EJB 从来没有实现他最初的设想：简化开发。EJB 的声明式编程模型的确简化了很多基础架构层面的开发，例如事务和安全；但另一方面 EJB 在部署描述符和配套代码实现等方面变得异常复杂。随着时间的推移，很多开发者对 EJB 不再抱有幻想，开始寻求更简洁的方法。</p><p>现在 Java 组件开发理念重新回归正轨。新的编程技术 AOP 和 DI 的不断出现，他们为 JavaBean 提供了之前 EJB 才能拥有的强大功能。这些技术为 POJO 提供类似 EJB 的声明式编程模型，而没有引入任何的 EJB 的复杂性。当简单的 JavaBean 足以胜任时，人们便不愿编写笨重的 EJB 组件了。</p><p>客观地讲，EJB 的发展甚至促进了基于 POJO 的编程模型。引入新的理念，最新的 EJB 规范相比之前的规范有了前所未有的简化，但对很多开发者而言，这一切的一切都来得太迟了。到了 EJB 3 规范发布时，其他基于 POJO 的开发架构已经成为事实的标准了，而 Spring 框架也是在这样的大环境下出现的。</p><h2 id="_3-2、spring-设计的初衷" tabindex="-1">3.2、Spring 设计的初衷 <a class="header-anchor" href="#_3-2、spring-设计的初衷" aria-label="Permalink to &quot;3.2、Spring 设计的初衷&quot;">​</a></h2><p>Spring 是为解决企业级应用开发的复杂性而设计，它可以做很多事。归根结底支撑 Spring 的仅仅是少许简单的基本理念，而一切都可以追溯到一个最根本的使命：简化开发。这是一个郑重地承诺，其实许多框架都声称在某些方面做了简化。</p><p>而 Spring 则立志于简化 Java 开发。对此，她主要采取了 4 个关键策略：</p><hr><ol><li><p>基于 POJO 的轻量级和最小侵入性编程</p></li><li><p>通过依赖注入和面向接口松耦合</p></li><li><p>基于切面和惯性进行声明式编程</p></li><li><p>通过切面和模板减少样板式代码</p></li></ol><hr><p>而他主要是通过：面向 Bean、依赖注入以及面向切面这三种范式来达成的。</p><h2 id="_3-3、bop-编程伊始" tabindex="-1">3.3、BOP 编程伊始 <a class="header-anchor" href="#_3-3、bop-编程伊始" aria-label="Permalink to &quot;3.3、BOP 编程伊始&quot;">​</a></h2><p>Spring 是面向 Bean 的 编程（Bean Oriented Programming , BOP），Bean 在 Spring 中才是真正的主角。Bean 在 Spring 中作用就像 Object 对 OOP 的意义一样，Spring 中没有 Bean 也就没有 Spring 存在的意义。Spring 提供了 IOC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系。</p><p>控制反转（其中最常见的方式叫做依赖注入（ Dependency injection， DI ），还有一种方式叫“依赖查找”（Dependency Lookup, DL），她在 C++、Java 、PHP 以及 .Net 中都运用。在最早的 Spring 中是包含有依赖注入方法和依赖查询的。但因为依赖查询使用频率过低，不久就被 Spring 移除了，所以在 Spring 中控制反转也被称作依赖注入，她的基本概念是：不创建对象，但是描述创建它们的方式。在代码中直接不让对象和服务连接，但在配置文件中描述哪一项服务。容器（在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。</p><p>在典型的 IOC 场景中，容器创建了所有的对象，并设置必要的属性将他们连接在一起，决定什么时间调用方法。</p><h2 id="_3-4、依赖注入的基本概念" tabindex="-1">3.4、依赖注入的基本概念 <a class="header-anchor" href="#_3-4、依赖注入的基本概念" aria-label="Permalink to &quot;3.4、依赖注入的基本概念&quot;">​</a></h2><p>Spring 设计的核心 <code>org.springframework.beans</code> 包（架构的核心是 org.springframework.core 包），它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 BeanFactory 接口，它是工厂设计模式的设想，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。</p><p>BeanFactory 支持两个对象模型:</p><ol><li><p>单例： 模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。用于无状态服务器对象很理想。</p></li><li><p>原型： 模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模式最适合。</p></li></ol><p>Bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 则将处理事情的责任从应用程序代码转移到了框架。</p><h2 id="_3-5、aop编程理念" tabindex="-1">3.5、AOP编程理念 <a class="header-anchor" href="#_3-5、aop编程理念" aria-label="Permalink to &quot;3.5、AOP编程理念&quot;">​</a></h2><p>面向切面编程，即 AOP，是一种编程思想，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面（切面），它将那些影响多个类的行为封装到可重用的模块中。</p><p>AOP 和 IOC 是补充性的技术，他们都运用模块化的方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上，当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。</p><p>AOP 的功能完全继承到了 Spring 事务管理、日志和其他各种特性的上下文中。</p><p>AOP 编程的常用场景有：Authentication 权限日志、Loggin 日志、Transctions Manager 事务、Lazy Loading 懒加载、Cotext Process 上下文处理、Error Handler 错误跟踪（异常捕获机制）、Cache 缓存</p><h2 id="_3-6、spring-5-系统架构" tabindex="-1">3.6、Spring 5 系统架构 <a class="header-anchor" href="#_3-6、spring-5-系统架构" aria-label="Permalink to &quot;3.6、Spring 5 系统架构&quot;">​</a></h2><p>Spring 总共大约有 20 个模块，由 1300 多个不同的文件构成。而这些组件被分别整合在核心容器（Core container）、AOP(Aspect Oriented Programming) 和设备支持（Instrmentation）、数据访问及继承（Data Access / Integeration）、Web、报文发送（Messaging）、Test，6个模块集合中。以下是 Spring 5 的模块结构图。</p><p><img src="'+i+'" alt="Spring手画架构图"></p><p>Spring 5 官网的说明：</p><p><img src="'+r+'" alt="Spring官方架构图"></p><p>组成 Spring 框架的每个模块的集合或者模块都可以单独存在，也可以一个或多个模块联合实现。每个模块的组成和功能如下：</p><p>1.核心容器：由 spring-beans、spring-core、spring-context、和spring-expression(spring Expression Language，SpEL) 4 个模块组成</p><p>spring-beans 和 spring- core 模块是 Spring 框架的核心模块。包含了控制反转（Inversion of control，IOC）和依赖注入（Dependency Injection, DI）。BeanFactory 接口是 Spring 框架中的核心接口，它是工厂模式的具体实现。BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean 被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。</p><p>spring-context模块构架于核心模块之上，他扩展了 BeanFactory，为她添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，BeanFactory 是它的超类。与 BeanFacotry不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装备，使之处于待用状态。</p><p>spring-expression 模块使统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便可以调用对象方法、操作数组、集合等。它的语法类似于传统的 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性使基于 Spring 产品的需求而设计，它可以非常方便的同 Spring IOC 进行交互。</p><p>2.AOP 和设备支持：由 spring-aop、spring-aspects 和 spring-instrument 3个模块组成。</p><p>spring-aop 是 Spring 的另一个核心模块，是AOP 主要的实现模块。作为继 OOP 后，对程序员影响最大的编程思想知意，AOP极大地开拓了人们对于编程的思路。在 Spring 中，他是以 JVM 的动态代理为基础，然后设计出了一系列的 AOP 横切实现，比如前置通知、返回通知、异常通知等。同时，Pointcut 接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。</p><p>spring-aspects模块继承自 AspectJ 框架，主要是为 Spring AOP 提供多种 AOP 实现方法。</p><p>spring-instrument 模块是基于 JAVA SE 中的 “java.lang.instrument”进行设计的，应该算是AOP 的一个支援模块，主要作用是在 JVM 启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能，在分类里，我把他分在了 AOP 模块下，在 Spring 官方文档里对这个地方也含糊不清，这里是纯个人观点。</p><p>3.数据访问及继承：由 spring-jdbc、spring-tx、spring-orm、spring-jms 和 spring-oxm 5个模块组成</p><p>spring-jdbc 模块是 Spring 提供的 JDBC 抽象框架的主要实现模块，用于简化 Spring JDBC。主要是提供 JDBC 模板方法、关系数据库对象化方式、SimpleJDBC 范式、事务管理来简化 JDBC 编程，主要实现类是 JDBCTemplate、SimpleJdbcTemplate 以及 NameParameterJdbcTemplate。</p><p>spring-tx 模块是 Spring JDBC 事务控制实现模块。使用 Spring 框架，它对事务做了很好的封装。通过它的 AOP 配置，可以灵活地配置在任何地方；但是在很多需求和应用，直接使用 JDBC 事务控制还是有其优势的。其实，事务是以业务逻辑为基础的：一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以事务控制是绝对应该放在业务层的；但是，持久层的设计原则应该需要很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用 Spring JDBC 事务控制时，应该注意其特殊性。</p><p>spring-orm 模块是 ORM 框架支持模块，主要集成 Hibernate，Java persistence API (JPA) 和 Java Data Objects (JDO) 用于资源管理、数据访问对象（DAO）的实现和事务策略。</p><p>spring-jms模块（Java Messageing Service）能够发送和接收消息，自 Spring Framework 4.1 以后，他还提供了对 spring-messaging 模块的支撑。</p><p>spring-orm 模块主要提供一个抽象层以支撑 OXM （Object-to-XML-Mapping的缩写，它是一个 O/M-mapper，将 java 对象映射成 XML 树，或者将 XML 数据映射成 java 对象），例如：JAVB，Castor，XMLBeans，JiBX 和 XStream 等。</p><p>4.Web: 有 spring-web、spring-webmvc、spring-webScoket 和 spring-webflux 4个模块组成。</p><p>spring-web模块为 spring 提供了最基础的 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持。</p><p>spring-webmvc 模块是一个 web-Servlet 模块，实现了 Spring MVC （model-view-controller）的Web 应用。</p>',54),g=[o];function s(c,J,S,l,m,d){return e(),n("div",null,g)}const O=a(t,[["render",s]]);export{B as __pageData,O as default};

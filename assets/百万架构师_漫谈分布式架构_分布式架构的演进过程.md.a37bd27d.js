import{_ as a,o as e,h as p,Q as t}from"./chunks/framework.da611722.js";const i="/assets/集群-厨师图解.1f84a953.png",l="/assets/洗菜-切菜-炒菜-拆分.3370c04e.png",o="/assets/单一架构.4115704d.jpg",r="/assets/应用和数据分离.aee59df1.jpg",n="/assets/集群架构.79c74433.png",s="/assets/Session会丢失.9e2204ed.jpg",h="/assets/数据库读写分离-优化.25a45589.jpg",d="/assets/架构最终图.0125ec34.png",c="/assets/ESB图解.884b272b.png",u="/assets/中间件发展图解.dfc345e2.png",m="/assets/冯诺依曼模型.4bc730ba.png",b="/assets/内存共享问题.3decdfa3.png",G=JSON.parse('{"title":"分布式架构的演进过程 | Java面试指南","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://javaguide.net/百万架构师/漫谈分布式架构/分布式架构的演进过程.html"}],["meta",{"name":"keywords","content":"分布式架构的演进过程 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"og:title","content":"分布式架构的演进过程 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"og:description","content":"分布式架构的演进过程 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://javaguide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"分布式架构的演进过程 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客"}],["meta",{"name":"twitter:description","content":"分布式架构的演进过程 | Java面试指南 | JavaGuide | Java面试指南 | NoGeek ｜不止极客 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://javaguide.net/JavaGuide-og.png"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/漫谈分布式架构/分布式架构的演进过程.md","filePath":"百万架构师/漫谈分布式架构/分布式架构的演进过程.md","lastUpdated":1740370683000}'),q={name:"百万架构师/漫谈分布式架构/分布式架构的演进过程.md"},g=t('<h1 id="分布式架构的演进过程" tabindex="-1">分布式架构的演进过程 <a class="header-anchor" href="#分布式架构的演进过程" aria-label="Permalink to &quot;分布式架构的演进过程&quot;">​</a></h1><ol><li>了解分布式架构中的相关概念</li><li>初始分布式架构的意义</li><li>分布式架构的发展过程和历史</li><li>分布式架构的演进过程</li><li>构建分布式架构最重要的因素</li></ol><h2 id="了解分布式结构中的相关概念" tabindex="-1">了解分布式结构中的相关概念 <a class="header-anchor" href="#了解分布式结构中的相关概念" aria-label="Permalink to &quot;了解分布式结构中的相关概念&quot;">​</a></h2><h2 id="第一个计算机时代" tabindex="-1">第一个计算机时代 <a class="header-anchor" href="#第一个计算机时代" aria-label="Permalink to &quot;第一个计算机时代&quot;">​</a></h2><p>集中式到分布式的发展历史</p><p>1946年ENIAC第一台计算机美国，</p><p>单台的计算机的性能不断地提升</p><p>以M为单位的内存到现在以G为单位的内存</p><p><strong>图灵</strong>，冯诺依曼</p><p>图灵：贡献了图灵机的理论模型</p><p><strong>冯诺依曼</strong>：提出了计算机体系结构的设想</p><h5 id="五个部分组成" tabindex="-1">五个部分组成 <a class="header-anchor" href="#五个部分组成" aria-label="Permalink to &quot;五个部分组成&quot;">​</a></h5><ol><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li></ol><h2 id="第二个计算机时代-大型主机时代" tabindex="-1">第二个计算机时代（大型主机时代） <a class="header-anchor" href="#第二个计算机时代-大型主机时代" aria-label="Permalink to &quot;第二个计算机时代（大型主机时代）&quot;">​</a></h2><p>IBM主导的大型主机时代</p><h2 id="第三个计算机时代" tabindex="-1">第三个计算机时代 <a class="header-anchor" href="#第三个计算机时代" aria-label="Permalink to &quot;第三个计算机时代&quot;">​</a></h2><h3 id="cisc-面向个人的pc" tabindex="-1">CISC 面向个人的pc <a class="header-anchor" href="#cisc-面向个人的pc" aria-label="Permalink to &quot;CISC 面向个人的pc&quot;">​</a></h3><p>面向个人的pc</p><h3 id="risc-面向企业小型linux的服务器-精简指令集" tabindex="-1">RISC 面向企业小型linux的服务器（精简指令集） <a class="header-anchor" href="#risc-面向企业小型linux的服务器-精简指令集" aria-label="Permalink to &quot;RISC 面向企业小型linux的服务器（精简指令集）&quot;">​</a></h3><p>注重高性能的主机</p><p>现在的编程语言越来越完善。</p><h3 id="编程语言发展历程" tabindex="-1">编程语言发展历程： <a class="header-anchor" href="#编程语言发展历程" aria-label="Permalink to &quot;编程语言发展历程：&quot;">​</a></h3><p>机器语言&gt;&gt;&gt;&gt;汇编语言</p><p>常用的指令集制定出一套标准</p><p>指令集功能化模块化的出现提升了性能。</p><p>指令集在计算机性能提升方面有一个非常大的里程碑。</p><p>Inter 出名的处理器8086</p><p>处理器加入很多指令去提升计算机的性能。</p><h4 id="二八理论" tabindex="-1">二八理论 <a class="header-anchor" href="#二八理论" aria-label="Permalink to &quot;二八理论&quot;">​</a></h4><p>20有用，80很少用</p><p>80%的指令集只在20%的场合里去使用</p><p>基于晶体管的电脑</p><p>如果一个电脑包含所有的指令集，就会出现一种情况：</p><p>​ 80%的指令集是不经常用的，20%的指令集会被经常调用</p><p>CISC（桌面级）</p><p>RISC（精简指令集）</p><p>大型计算机是主流，凭借IO处理能力和稳定性、安全性！！！</p><p>基于大型主机进行的集中式架构、计算</p><h4 id="大型主机的问题" tabindex="-1">大型主机的问题 <a class="header-anchor" href="#大型主机的问题" aria-label="Permalink to &quot;大型主机的问题&quot;">​</a></h4><ol><li>复杂性，运维和维护很贵</li><li>很贵，</li><li>大型主机是一个单点的机器</li><li>我们的摩尔定律，个人电脑不断提升</li></ol><h4 id="去ioe" tabindex="-1">去IOE <a class="header-anchor" href="#去ioe" aria-label="Permalink to &quot;去IOE&quot;">​</a></h4><p>09年阿里发起了去IOE运动（利用国内外的开源中间件实现分布式架构）</p><ol><li>IBM的小型机</li><li>ORACLE数据库（商业数据库）</li><li>EMC的存储设备</li></ol><p>13年完成最后一台小型机的替换。</p><p>12年开源了Dubbo</p><h4 id="分布式架构好处" tabindex="-1">分布式架构好处： <a class="header-anchor" href="#分布式架构好处" aria-label="Permalink to &quot;分布式架构好处：&quot;">​</a></h4><ol><li>吞吐量很高</li><li>迭代很快</li></ol><p>分布式架构的意义</p><ol><li>单机的提升投入产出比不高</li><li>单机处理的瓶颈</li><li>稳定性和可用性</li></ol><h2 id="分布式架构的常见概念" tabindex="-1">分布式架构的常见概念 <a class="header-anchor" href="#分布式架构的常见概念" aria-label="Permalink to &quot;分布式架构的常见概念&quot;">​</a></h2><p>集群</p><p>分布式</p><p>节点</p><p>副本机制</p><p>中间件</p><h3 id="集群" tabindex="-1">集群 <a class="header-anchor" href="#集群" aria-label="Permalink to &quot;集群&quot;">​</a></h3><p><img src="'+i+'" alt="集群-厨师图解"></p><h3 id="分布式" tabindex="-1">分布式 <a class="header-anchor" href="#分布式" aria-label="Permalink to &quot;分布式&quot;">​</a></h3><p>我把一个业务按照某种规则去拆分成多个模块</p><p>多个模块之间进行消息通讯</p><p>然后达到一个整体。</p><p>应用层的分布式架构。</p><p>应用层按照某个领域去拆分</p><p><img src="'+l+'" alt="洗菜-切菜-炒菜-拆分"></p><p>DDD领域驱动</p><h3 id="节点" tabindex="-1">节点 <a class="header-anchor" href="#节点" aria-label="Permalink to &quot;节点&quot;">​</a></h3><p>独立按照分布式协议去完成一个完整逻辑的个体。叫做一个节点</p><h3 id="数据副本" tabindex="-1">数据副本 <a class="header-anchor" href="#数据副本" aria-label="Permalink to &quot;数据副本&quot;">​</a></h3><p>数据的相互备份：数据副本的概念。避免单点故障</p><h3 id="中间件" tabindex="-1">中间件 <a class="header-anchor" href="#中间件" aria-label="Permalink to &quot;中间件&quot;">​</a></h3><p>中间：应用层和操作系统之间的一个位置。</p><p>这个软件提供了一个操作系统服务之外的一些服务，而且也不能定义为应用层面的中间件。</p><p>能够让程序开发人员，更方便地去输入输出，通讯，关注他自己关注的领域</p><p>（消息中间件，缓存中间件，RPC框架）</p><h2 id="架构发展过程" tabindex="-1">架构发展过程 <a class="header-anchor" href="#架构发展过程" aria-label="Permalink to &quot;架构发展过程&quot;">​</a></h2><p>架构跟着业务去发展，架构支持一定的并发量。</p><p>需要前瞻性地考虑一些问题</p><p>业务有多大体量，我去支撑就好了</p><p>电商平台架构的发展历程。</p><ol><li>按照产品维度去看待问题</li><li>基于数据量、访问量的提升</li><li>网站的结构发生了变化</li></ol><h3 id="单一的架构" tabindex="-1">单一的架构 <a class="header-anchor" href="#单一的架构" aria-label="Permalink to &quot;单一的架构&quot;">​</a></h3><p><img src="'+o+'" alt="单一架构"></p><ol><li><p>定义一些指标，检测用户的访问量，以及监控后台CPU的使用情况。</p></li><li><p>被动的服务卡掉了</p></li></ol><h3 id="应用和数据分离" tabindex="-1">应用和数据分离 <a class="header-anchor" href="#应用和数据分离" aria-label="Permalink to &quot;应用和数据分离&quot;">​</a></h3><p>便于针对某个服务器做垂直升级</p><p><img src="'+r+'" alt="应用和数据分离"></p><h3 id="集群架构" tabindex="-1">集群架构 <a class="header-anchor" href="#集群架构" aria-label="Permalink to &quot;集群架构&quot;">​</a></h3><p><img src="'+n+'" alt="集群架构"></p><p>通过域名去访问，</p><p>DNS去解析，ip地址+端口号。</p><p>http是无状态的</p><p>通过session保存会话状态，在tomcat中生成的。</p><p>Session是服务端的对象，</p><p>Cookie是浏览器的对象。</p><p>Cookie中存储sessionId</p><p>完成会话状态的保存。</p><p>Cookie有效范围</p><h5 id="session会丢失" tabindex="-1">Session会丢失 <a class="header-anchor" href="#session会丢失" aria-label="Permalink to &quot;Session会丢失&quot;">​</a></h5><p>集群，访问到不同的服务器上边。</p><p><img src="'+s+'" alt="Session会丢失"></p><h5 id="数据库读写分离-优化" tabindex="-1">数据库读写分离-优化 <a class="header-anchor" href="#数据库读写分离-优化" aria-label="Permalink to &quot;数据库读写分离-优化&quot;">​</a></h5><p><img src="'+h+'" alt="数据库读写分离-优化"></p><p>数据库的水平拆分，</p><p>读写分离。</p><p>通过什么方式做数据的路由。</p><p>用什么做mysql的数据同步。</p><p>Binglog</p><p>网络延迟带来的短暂的不同步的状态</p><p>减轻读库的压力。</p><p>DB mycat做数据路由的中间件。</p><h5 id="搜索引擎做检索的问题" tabindex="-1">搜索引擎做检索的问题 <a class="header-anchor" href="#搜索引擎做检索的问题" aria-label="Permalink to &quot;搜索引擎做检索的问题&quot;">​</a></h5><p>Slor luence electicsearch</p><p>ES 基于源数据做一个索引，</p><p>全量的同步，还是增量的同步</p><p>同步同步，还是异步同步。</p><p>数据分析，智能推送</p><p>基于访问量激增，</p><p>很多人会访问同一块数据，热点数据，</p><p>经常访问，频繁访问的。</p><h5 id="缓存中间件" tabindex="-1">缓存中间件 <a class="header-anchor" href="#缓存中间件" aria-label="Permalink to &quot;缓存中间件&quot;">​</a></h5><p>用缓存中间件 redis做缓存中间件。</p><p>最早的缓存来自于CPU的缓存。</p><p>应用层面利用缓存，</p><p>基于源数据的副本，</p><p>NoSql not only sql</p><p>非关系型数据库的数据存储。</p><p>利用redis做缓存。</p><ol><li>缓存雪崩</li><li>缓存击穿</li><li>缓存的持久化</li></ol><p>基于缓存做双读双写，</p><p>数据库与缓存之间的同步问题</p><p>这中间会有一致性的问题。</p><p>先读缓存，再读数据库</p><p>怎么解决。</p><h5 id="数据库问题" tabindex="-1">数据库问题 <a class="header-anchor" href="#数据库问题" aria-label="Permalink to &quot;数据库问题&quot;">​</a></h5><p><strong>PV</strong> 即 <strong>Page View</strong>，页面浏览量， 用户每一次对网站中的每个页面访问均被记录1次。用户对同一页面的多次刷新，访问量是进行累计的。</p><p>PV, GV 方面</p><ol><li><p>数据IO</p></li><li><p>数据量大</p></li></ol><p>IO大的话，性能会降低</p><p>数据量大的话，性能会降低，</p><p>数据可以垂直分库</p><p>按照业务的维度拆分数据库，不同的业务所使用的数据库放在不同的数据库中。</p><p>对数据库进行独立的部署，IO的问题。</p><p>分库分表，</p><p>分库：垂直拆分</p><p>分表：水平拆分（分片）</p><p>数据量大的问题。</p><p>一亿的数据量，</p><ol><li>数据库做隔离，</li><li>保证在线数据，离线数据的指标</li><li>运维人员与使用人员的隔离。</li></ol><p>数据库可以看作是分布式</p><p>Redis可以看作是分布式数据库。</p><p>开发，运维需要拆分，</p><h5 id="架构最终图" tabindex="-1">架构最终图 <a class="header-anchor" href="#架构最终图" aria-label="Permalink to &quot;架构最终图&quot;">​</a></h5><p><img src="'+d+'" alt="架构最终图"></p><h3 id="领域驱动" tabindex="-1">领域驱动 <a class="header-anchor" href="#领域驱动" aria-label="Permalink to &quot;领域驱动&quot;">​</a></h3><p>业务模型，按照领域驱动做拆分，</p><p>每一个模块做一个单独的项目</p><p>可以独立发布，或者做集群。</p><h5 id="提炼" tabindex="-1">提炼 <a class="header-anchor" href="#提炼" aria-label="Permalink to &quot;提炼&quot;">​</a></h5><p>一个服务的提炼，对外有web，有service的调用。</p><p>模块之间可以相互调用</p><p>Rpc、http,</p><p>面向服务的变成不是完全的SOA，服务之间相互调用，调用链非常复杂。</p><p>为了整理服务之间的调用</p><h5 id="soa-esb" tabindex="-1">SOA：ESB <a class="header-anchor" href="#soa-esb" aria-label="Permalink to &quot;SOA：ESB&quot;">​</a></h5><p>企业服务总线，</p><p>所有的调用全部调用ESB。</p><p>帮你屏蔽一些服务的信息，包括不同的数据协议，不同的数据格式，都可以进行统一的约束。</p><p><img src="'+c+'" alt="ESB图解"></p><h5 id="网关" tabindex="-1">网关 <a class="header-anchor" href="#网关" aria-label="Permalink to &quot;网关&quot;">​</a></h5><p>服务层单独做服务。</p><p>基于Ngix+lua做网关，</p><p>通过网关可以</p><ol><li>隔离内外网。</li><li>做接口的处理路由</li></ol><h5 id="消息服务总线。" tabindex="-1">消息服务总线。 <a class="header-anchor" href="#消息服务总线。" aria-label="Permalink to &quot;消息服务总线。&quot;">​</a></h5><h3 id="梳理一下架构" tabindex="-1">梳理一下架构 <a class="header-anchor" href="#梳理一下架构" aria-label="Permalink to &quot;梳理一下架构&quot;">​</a></h3><p>终端 &gt;&gt;&gt;&gt; web（应用服务） &gt;&gt;&gt;&gt; （服务治理的中间件） &gt;&gt;&gt;&gt; 领域服务 &gt;&gt;&gt;&gt; （数据库治理中间件） &gt;&gt;&gt;&gt; 数据库</p><p>服务治理中间件：dubbo</p><p>消息中间件：rabbitmq/kafka</p><p>数据库中间件：mycat/charding-jdbc</p><p>缓存：redis</p><p>配置中心：</p><p>定时调度中心：</p><p>链路调用监控系统调用</p><p>架构的发展不是一蹴而就的。</p><p>是慢慢地发展的。</p><p><img src="'+u+'" alt="中间件发展图解"></p><h5 id="冯诺依曼模型" tabindex="-1">冯诺依曼模型 <a class="header-anchor" href="#冯诺依曼模型" aria-label="Permalink to &quot;冯诺依曼模型&quot;">​</a></h5><p><img src="'+m+'" alt="冯诺依曼模型"></p><p>输入设备：（各个节点之间的通讯，服务之间的通讯，人机交互）</p><p>存储器：（关系型数据库、Nosql，分布式文件存储）</p><p>运算器：（领域服务）</p><p>控制器（LVS/ngis/规则引擎/调度）</p><p>输出设备（通讯的返回值，用户端的界面展示）</p><p>​</p><p>整个分布式架构可以看作是超级计算机。</p><h5 id="浅谈并发" tabindex="-1">浅谈并发 <a class="header-anchor" href="#浅谈并发" aria-label="Permalink to &quot;浅谈并发&quot;">​</a></h5><p>最早的并发，计算机的并发。</p><p>如何隔离不同指令</p><p>如何进行指令的切换，</p><p>进行内存隔离，</p><p>进行文件隔离，</p><p>然后出现了进程，</p><p>进程的调度</p><p>共享内存</p><p><img src="'+b+'" alt="内存共享问题"></p><p>进程需要CPU时间片的切换才能够实现真正意义上的并行。</p><p>进程中出现了线程，</p><p>线程是CPU调度的最小单元！</p><p>线程可以达到真正意义上进程内的一个并行</p><p>在进程内达到多个线程的并行。</p><p>线程的创建和切换的开销比较小</p><h5 id="线程不安全问题。" tabindex="-1">线程不安全问题。 <a class="header-anchor" href="#线程不安全问题。" aria-label="Permalink to &quot;线程不安全问题。&quot;">​</a></h5><p>线程和内存之间会有本地内存，存储变量的缓存</p><p>类似于分布式架构缓存一致性的问题。</p><h1 id="分布式架构的难点" tabindex="-1">分布式架构的难点 <a class="header-anchor" href="#分布式架构的难点" aria-label="Permalink to &quot;分布式架构的难点&quot;">​</a></h1><h3 id="_1-三态" tabindex="-1">1. 三态 <a class="header-anchor" href="#_1-三态" aria-label="Permalink to &quot;1.   三态&quot;">​</a></h3><p>a. 成功</p><p>b. 失败</p><p>c. 超时或者未知</p><h3 id="_2-分布式事务" tabindex="-1">2. 分布式事务 <a class="header-anchor" href="#_2-分布式事务" aria-label="Permalink to &quot;2.   分布式事务&quot;">​</a></h3><p>（多个存储节点下的数据库一致性问题）</p><h3 id="_3-负载均衡" tabindex="-1">3. 负载均衡 <a class="header-anchor" href="#_3-负载均衡" aria-label="Permalink to &quot;3.   负载均衡&quot;">​</a></h3><p>（入口端的负载，领域服务层的负载、服务发现）</p><h3 id="_4-一致性" tabindex="-1">4. 一致性 <a class="header-anchor" href="#_4-一致性" aria-label="Permalink to &quot;4.   一致性&quot;">​</a></h3><p>（CAP）</p><h3 id="_5-故障的独立性" tabindex="-1">5. 故障的独立性 <a class="header-anchor" href="#_5-故障的独立性" aria-label="Permalink to &quot;5.   故障的独立性&quot;">​</a></h3><p>（隔离，故障的隔离，单个节点的故障不影响集群的运行）</p><p>CAP</p><p>BASE</p><p>领域驱动</p><p>分布式架构的组成因素。</p><p>Xsell sftp：一些终端的一些工具。</p>',232),_=[g];function f(k,P,x,v,S,J){return e(),p("div",null,_)}const I=a(q,[["render",f]]);export{G as __pageData,I as default};

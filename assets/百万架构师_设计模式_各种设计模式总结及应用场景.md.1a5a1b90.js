import{_ as a,o as e,h as t,Q as n}from"./chunks/framework.da611722.js";const l="/assets/AOP图解.d46c10c2.png",m=JSON.parse('{"title":"各种设计模式总结及应用场景 | JavaGuide","description":"","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://JavaGuide.net/百万架构师/设计模式/各种设计模式总结及应用场景.html"}],["meta",{"name":"keywords","content":"各种设计模式总结及应用场景 , JavaGuide , JavaGuide官网, Java面试指南, Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"}],["meta",{"name":"og:url","content":"https://JavaGuide.net"}],["meta",{"name":"og:type","content":"website"}],["meta",{"name":"og:image","content":"https://JavaGuide.net/og.png"}],["meta",{"name":"og:title","content":"各种设计模式总结及应用场景 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"og:description","content":"各种设计模式总结及应用场景 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:site","content":"https://JavaGuide.net"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:creator","content":"nogeek.cn"}],["meta",{"name":"twitter:title","content":"各种设计模式总结及应用场景 | JavaGuide | Java面试指南 | JavaGuide官网"}],["meta",{"name":"twitter:description","content":"各种设计模式总结及应用场景 | JavaGuide | Java面试指南 | JavaGuide官网 | 「JavaGuide.net」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide.net ！"}],["meta",{"name":"twitter:image","content":"https://JavaGuide.net/og.png"}],["meta",{"name":"sogou_site_verification","content":"fcAkazTXFd"}],["meta",{"name":"baidu-site-verification","content":"codeva-MXEPYsXKGk"}],["meta",{"name":"msvalidate.01","content":"9F2D57CFC59E8031212A166878638B15"}]]},"headers":[],"relativePath":"百万架构师/设计模式/各种设计模式总结及应用场景.md","filePath":"百万架构师/设计模式/各种设计模式总结及应用场景.md","lastUpdated":1741277271000}'),s={name:"百万架构师/设计模式/各种设计模式总结及应用场景.md"},r=n(`<h1 id="总结设计模式之间的差别和应用场景" tabindex="-1">总结设计模式之间的差别和应用场景 <a class="header-anchor" href="#总结设计模式之间的差别和应用场景" aria-label="Permalink to &quot;总结设计模式之间的差别和应用场景&quot;">​</a></h1><hr><ul><li><strong>不要生搬硬套，根据业务场景选择</strong></li><li><strong>不要把简单的事情搞复杂，设计模式是用来解决复杂问题的</strong></li><li><strong>把复杂的问题变得简单起来，（总结利用好前人的经验）</strong></li></ul><hr><h1 id="工厂模式-创建型" tabindex="-1">工厂模式：（创建型） <a class="header-anchor" href="#工厂模式-创建型" aria-label="Permalink to &quot;工厂模式：（创建型）&quot;">​</a></h1><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">graph</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LR</span></span>
<span class="line"><span style="color:#FFAB70;">原始社会</span><span style="color:#F97583;">[</span><span style="color:#9ECBFF;">原始社会</span><span style="color:#F97583;">]--&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">农耕社会</span><span style="color:#F97583;">[</span><span style="color:#9ECBFF;">农耕社会</span><span style="color:#F97583;">]</span></span>
<span class="line"><span style="color:#FFAB70;">农耕社会 </span><span style="color:#F97583;">--&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">小作坊</span><span style="color:#F97583;">[</span><span style="color:#9ECBFF;">小作坊</span><span style="color:#F97583;">]</span></span>
<span class="line"><span style="color:#FFAB70;">小作坊</span><span style="color:#F97583;">--&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">工厂</span><span style="color:#F97583;">[</span><span style="color:#9ECBFF;">工厂</span><span style="color:#F97583;">]</span></span>
<span class="line"><span style="color:#FFAB70;">工厂</span><span style="color:#F97583;">--&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">流水线生产</span><span style="color:#F97583;">[</span><span style="color:#9ECBFF;">流水线生产</span><span style="color:#F97583;">]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">graph</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LR</span></span>
<span class="line"><span style="color:#E36209;">原始社会</span><span style="color:#D73A49;">[</span><span style="color:#032F62;">原始社会</span><span style="color:#D73A49;">]--&gt;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">农耕社会</span><span style="color:#D73A49;">[</span><span style="color:#032F62;">农耕社会</span><span style="color:#D73A49;">]</span></span>
<span class="line"><span style="color:#E36209;">农耕社会 </span><span style="color:#D73A49;">--&gt;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">小作坊</span><span style="color:#D73A49;">[</span><span style="color:#032F62;">小作坊</span><span style="color:#D73A49;">]</span></span>
<span class="line"><span style="color:#E36209;">小作坊</span><span style="color:#D73A49;">--&gt;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">工厂</span><span style="color:#D73A49;">[</span><span style="color:#032F62;">工厂</span><span style="color:#D73A49;">]</span></span>
<span class="line"><span style="color:#E36209;">工厂</span><span style="color:#D73A49;">--&gt;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">流水线生产</span><span style="color:#D73A49;">[</span><span style="color:#032F62;">流水线生产</span><span style="color:#D73A49;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h1 id="spring-中-beanfacotry-生产出来-factorybean" tabindex="-1">Spring 中 ----BeanFacotry 生产出来 FactoryBean <a class="header-anchor" href="#spring-中-beanfacotry-生产出来-factorybean" aria-label="Permalink to &quot;Spring 中 ----BeanFacotry  生产出来 FactoryBean&quot;">​</a></h1><h1 id="单例模式" tabindex="-1">单例模式： <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式：&quot;">​</a></h1><p>​ <strong>通过技术手段保证整个系统运行阶段，只有一个实例</strong></p><h3 id="场景" tabindex="-1">场景： <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景：&quot;">​</a></h3><ul><li>配置文件</li><li>监控程序</li><li>IOC 容器</li><li>日历</li></ul><h3 id="实现手段" tabindex="-1">实现手段： <a class="header-anchor" href="#实现手段" aria-label="Permalink to &quot;实现手段：&quot;">​</a></h3><ul><li>懒汉式</li><li>饿汉式</li><li>注册登记式</li><li>反序列化处理</li></ul><h3 id="spring-中最常用的-注册登记式" tabindex="-1">Spring 中最常用的 注册登记式 <a class="header-anchor" href="#spring-中最常用的-注册登记式" aria-label="Permalink to &quot;Spring 中最常用的  注册登记式&quot;">​</a></h3><h3 id="效率最高" tabindex="-1">效率最高 <a class="header-anchor" href="#效率最高" aria-label="Permalink to &quot;效率最高&quot;">​</a></h3><h5 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h5><h1 id="原型模式-复制" tabindex="-1">原型模式：复制 <a class="header-anchor" href="#原型模式-复制" aria-label="Permalink to &quot;原型模式：复制&quot;">​</a></h1><p>​ <strong>Spring 中的对象原型，主要是为了配置信息能够被重复使用，而且互不干扰</strong></p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">Bean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scope</span><span style="color:#E1E4E8;"> = </span><span style="color:#9ECBFF;">&quot;prototype&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">list</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">list</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">Bean</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">Bean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scope</span><span style="color:#24292E;"> = </span><span style="color:#032F62;">&quot;prototype&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">list</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">list</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">Bean</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="技术手段" tabindex="-1">技术手段 <a class="header-anchor" href="#技术手段" aria-label="Permalink to &quot;技术手段&quot;">​</a></h3><ul><li>实现 cloneable 重写 clone 方法</li><li>字节码操作来实现（效率最高）</li><li>通过反射机制来实现（Spring 中常用）</li></ul><h1 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h1><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li>中介</li><li>黄牛</li><li>经纪人</li></ul><h3 id="代码场景" tabindex="-1">代码场景： <a class="header-anchor" href="#代码场景" aria-label="Permalink to &quot;代码场景：&quot;">​</a></h3><ul><li>字节码增强</li><li>动态实现非侵入式编程</li></ul><h5 id="完成一件事情-代理只参与某一部分的功能" tabindex="-1">完成一件事情：代理只参与某一部分的功能 <a class="header-anchor" href="#完成一件事情-代理只参与某一部分的功能" aria-label="Permalink to &quot;完成一件事情：代理只参与某一部分的功能&quot;">​</a></h5><h3 id="技术手段-1" tabindex="-1">技术手段： <a class="header-anchor" href="#技术手段-1" aria-label="Permalink to &quot;技术手段：&quot;">​</a></h3><ul><li><p>JKD Proxy</p></li><li><p>Cglib</p></li><li><p>AspectJ</p></li><li><p>asm</p><p>​ 我们通过代码演示，自己模拟实现了 JKD 动态代理底层</p></li></ul><h1 id="策略模式" tabindex="-1">策略模式： <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式：&quot;">​</a></h1><p>​ <strong>将一些固定的算法统一起来</strong></p><h3 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li>旅游路线的选择</li><li>出行方式的选择</li></ul><h3 id="代码场景-1" tabindex="-1">代码场景： <a class="header-anchor" href="#代码场景-1" aria-label="Permalink to &quot;代码场景：&quot;">​</a></h3><ul><li>支付方式的选择</li></ul><h3 id="特点" tabindex="-1">特点： <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点：&quot;">​</a></h3><p>​ <strong>巧妙地避免了 if... else... 或者 switch 语句</strong></p><h1 id="模板方法" tabindex="-1">模板方法: <a class="header-anchor" href="#模板方法" aria-label="Permalink to &quot;模板方法:&quot;">​</a></h1><p>​ <strong>流程固定，某一个环节有差异</strong></p><h3 id="应用场景-2" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景-2" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><ul><li>JDBCTemplate</li><li>工作流</li></ul><h3 id="代码场景-2" tabindex="-1">代码场景 <a class="header-anchor" href="#代码场景-2" aria-label="Permalink to &quot;代码场景&quot;">​</a></h3><ul><li>模拟 Spring JdbcTemplate 的简单实现</li><li>Spring-ORM - 单表操作不需要写一句 SQL</li></ul><h1 id="委派模式" tabindex="-1">委派模式： <a class="header-anchor" href="#委派模式" aria-label="Permalink to &quot;委派模式：&quot;">​</a></h1><p>​ <strong>代理模式的特殊情况，全权代理</strong></p><h3 id="应用场景-3" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景-3" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><ul><li>项目经理</li><li>Dispatcher</li></ul><h3 id="代码场景-3" tabindex="-1">代码场景： <a class="header-anchor" href="#代码场景-3" aria-label="Permalink to &quot;代码场景：&quot;">​</a></h3><ul><li>Spring 中的 ServletDispatcher， Delegate 命名结尾的都是委派模式</li></ul><h1 id="适配器模式" tabindex="-1">适配器模式： <a class="header-anchor" href="#适配器模式" aria-label="Permalink to &quot;适配器模式：&quot;">​</a></h1><ul><li>兼容</li><li>转换</li></ul><h3 id="应用场景-4" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景-4" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><ul><li>一拖三转换头</li><li>HDMI 转 VGA</li><li>编码和解码</li></ul><h3 id="代码场景-4" tabindex="-1">代码场景 <a class="header-anchor" href="#代码场景-4" aria-label="Permalink to &quot;代码场景&quot;">​</a></h3><ul><li>登陆，为了兼容旧系统的登录功能，在老基础之上进行兼容编程</li></ul><h3 id="spring-中-以-adapter-结尾的" tabindex="-1">Spring 中 以 Adapter 结尾的 <a class="header-anchor" href="#spring-中-以-adapter-结尾的" aria-label="Permalink to &quot;Spring 中 以 Adapter 结尾的&quot;">​</a></h3><h1 id="装饰器模式" tabindex="-1">装饰器模式： <a class="header-anchor" href="#装饰器模式" aria-label="Permalink to &quot;装饰器模式：&quot;">​</a></h1><p>委派 + 适配器</p><ul><li>扩展</li><li>覆盖</li></ul><p>is - a （同宗同源）</p><h3 id="应用场景-5" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景-5" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><ul><li>I/O 流</li><li>数据源</li></ul><h3 id="代码" tabindex="-1">代码： <a class="header-anchor" href="#代码" aria-label="Permalink to &quot;代码：&quot;">​</a></h3><ul><li>用代码改造了一个旧的系统</li></ul><h3 id="spring-中-dercoator-结尾-weapper-结尾的" tabindex="-1">Spring 中 Dercoator 结尾 ， Weapper 结尾的 <a class="header-anchor" href="#spring-中-dercoator-结尾-weapper-结尾的" aria-label="Permalink to &quot;Spring 中 Dercoator 结尾 ， Weapper 结尾的&quot;">​</a></h3><h1 id="观察者模式" tabindex="-1">观察者模式： <a class="header-anchor" href="#观察者模式" aria-label="Permalink to &quot;观察者模式：&quot;">​</a></h1><p>​ <strong>针对于目标对象的一举一动，要得到一个反馈。</strong></p><h3 id="应用场景-6" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景-6" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><ul><li>事件监听</li><li>日志监听</li><li>短信通知</li></ul><h4 id="代码场景-5" tabindex="-1">代码场景： <a class="header-anchor" href="#代码场景-5" aria-label="Permalink to &quot;代码场景：&quot;">​</a></h4><ul><li>Listenter</li><li>Monitor</li><li>Observer</li></ul><h3 id="spring-中-listener-通常会结合动态代理" tabindex="-1">Spring 中 Listener （通常会结合动态代理） <a class="header-anchor" href="#spring-中-listener-通常会结合动态代理" aria-label="Permalink to &quot;Spring 中 Listener （通常会结合动态代理）&quot;">​</a></h3><h1 id="各设计模式对比及编程思想总结" tabindex="-1">各设计模式对比及编程思想总结 <a class="header-anchor" href="#各设计模式对比及编程思想总结" aria-label="Permalink to &quot;各设计模式对比及编程思想总结&quot;">​</a></h1><table><thead><tr><th>设计模式</th><th>一句话归纳</th></tr></thead><tbody><tr><td>工厂模式（Factory）</td><td>只对结果负责，不要三无产品</td></tr><tr><td>单例模式（Singleton）</td><td>保证独一无二</td></tr><tr><td>适配器模式（Adapter）</td><td>需要一个转换头（兼容）</td></tr><tr><td>装饰器模式（Decorator）</td><td>需要包装，但不改变本质（同宗同源）</td></tr><tr><td>代理模式（Proxy）</td><td>办事要求人，所以找代理。</td></tr><tr><td>观察者模式（Observer）</td><td>完成时通知我</td></tr><tr><td>策略模式（Startegy）</td><td>我行我素，达到目的就行。</td></tr><tr><td>模板模式（Template）</td><td>流程表标准化，原料自己加。</td></tr><tr><td>委派模式（Delegate）</td><td>干活是你的（普通员工），功劳是我的（项目经理）</td></tr><tr><td>原型模式（Prototype）</td><td>拔一根猴毛，吹出千万个。</td></tr></tbody></table><h1 id="编程思想" tabindex="-1">编程思想 <a class="header-anchor" href="#编程思想" aria-label="Permalink to &quot;编程思想&quot;">​</a></h1><h2 id="spring-中的编程思想" tabindex="-1">Spring 中的编程思想 <a class="header-anchor" href="#spring-中的编程思想" aria-label="Permalink to &quot;Spring 中的编程思想&quot;">​</a></h2><h3 id="aop-面向切面编程-动态代理" tabindex="-1">AOP：面向切面编程，动态代理 <a class="header-anchor" href="#aop-面向切面编程-动态代理" aria-label="Permalink to &quot;AOP：面向切面编程，动态代理&quot;">​</a></h3><ul><li>动态代理只是AOP 的一种技术手段，AOP 只是一种编程思想</li></ul><p>Aspect 切面</p><h5 id="aop图解-png" tabindex="-1">==AOP图解.png== <a class="header-anchor" href="#aop图解-png" aria-label="Permalink to &quot;==AOP图解.png==&quot;">​</a></h5><p><img src="`+l+'" alt="AOP图解.png"></p><h3 id="oop-封装、继承、多态-一切皆对象" tabindex="-1">OOP：封装、继承、多态（一切皆对象） <a class="header-anchor" href="#oop-封装、继承、多态-一切皆对象" aria-label="Permalink to &quot;OOP：封装、继承、多态（一切皆对象）&quot;">​</a></h3><p>​ 现象（关注技术细节，面向过程）</p><p>​ 关心的事物之间的联系</p><h4 id="正确-用代码去描述这个世界" tabindex="-1">正确：用代码去描述这个世界 <a class="header-anchor" href="#正确-用代码去描述这个世界" aria-label="Permalink to &quot;正确：用代码去描述这个世界&quot;">​</a></h4><p>​ 毛病：接到需求就是干!!</p><h3 id="bop-bean-与-bean-之间的关系-不希望每次人为地重复管理-由程序来实现自动管理" tabindex="-1">BOP：Bean 与 Bean 之间的关系，不希望每次人为地重复管理，由程序来实现自动管理 <a class="header-anchor" href="#bop-bean-与-bean-之间的关系-不希望每次人为地重复管理-由程序来实现自动管理" aria-label="Permalink to &quot;BOP：Bean 与 Bean 之间的关系，不希望每次人为地重复管理，由程序来实现自动管理&quot;">​</a></h3><p>​ <strong>Spring 开始就是自从 Bean 的管理开始的</strong></p><p>new 个不停，配置 Hibernate 的对象关系</p><p>配置 ORM 的时候，Teacher， Student</p><h3 id="ioc-控制反转-创建对象的控制权反转" tabindex="-1">IOC：控制反转：创建对象的控制权反转： <a class="header-anchor" href="#ioc-控制反转-创建对象的控制权反转" aria-label="Permalink to &quot;IOC：控制反转：创建对象的控制权反转：&quot;">​</a></h3><p>​ <strong>new， 谁使用 谁 new</strong></p><p>​ <strong>有了 Spring 以后，所有的 Bean 都由 Spring 来 new, 所以才叫控制反转</strong></p><p>​ <strong>new 出来以后的对象需要统一管理起来，所以才有了 IOC 容器 （Map）</strong></p><h3 id="di-技术-解决对象动态赋值的问题" tabindex="-1">DI 技术：解决对象动态赋值的问题 <a class="header-anchor" href="#di-技术-解决对象动态赋值的问题" aria-label="Permalink to &quot;DI 技术：解决对象动态赋值的问题&quot;">​</a></h3><p>​ <strong>动态地调用 getter、setter (采用反射)</strong></p><p>​ <strong>Spring 的加载步骤： 定位、载入、注册；再确定要不要初始化 Bean</strong></p><h1 id="编程思想总结" tabindex="-1">编程思想总结 <a class="header-anchor" href="#编程思想总结" aria-label="Permalink to &quot;编程思想总结&quot;">​</a></h1><table><thead><tr><th>Spring 思想</th><th>应用场景（特点）</th><th>一句话归纳</th></tr></thead><tbody><tr><td>AOP</td><td>Aspect Oriented Programming（面向切面编程）<br>找出多个类中有一定规律的代码，开发时拆开，运行时再合并。<br>面向切面编程，即面向规则编程。</td><td>解耦，专人做专事</td></tr><tr><td>OOP</td><td>Object Oriented programming（面向对象编程）<br>归纳总结生活中一切事物</td><td>封装、继承、多态</td></tr><tr><td>BOP</td><td>Bean Oriented Programming（面向 Bean 编程）<br>面向 Bean （普通的 java 类）设计程序。</td><td>一切从 Bean 开始</td></tr><tr><td>IOC</td><td>Inversion of Control（控制反转）<br>将 new 对象的动作交给 Spring 管理，并由 Spring 保存已创建的对象（IOC容器）</td><td>转交控制权（即控制反转）</td></tr><tr><td>DI/DL</td><td>Dependency Injection（依赖注入）或者 Dependency Lookup（依赖查找）<br>依赖注入、依赖查找，Spring 不仅保存自己创建的对象，而且保存对象与对象之间的关系。<br>注入即复制，主要三种方式构造方法、set 方法、直接赋值。</td><td>先清理关系再赋值。</td></tr></tbody></table>',99),o=[r];function i(p,c,d,h,u,b){return e(),t("div",null,o)}const y=a(s,[["render",i]]);export{m as __pageData,y as default};
